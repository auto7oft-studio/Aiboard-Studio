<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aiboard Studio | 에디터</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link rel="stylesheet" as="style" crossorigin
        href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.min.css" />
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Noto+Sans+KR:wght@400;700&family=Noto+Serif+KR:wght@400;700&family=Roboto:wght@400;700&family=Nanum+Gothic:wght@400;700&family=Nanum+Myeongjo:wght@400;700&family=Black+Han+Sans&family=Do+Hyeon&family=Gowun+Dodum&display=swap"
        rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/opentype.js/1.3.4/opentype.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.5.136/pdf.min.js"></script>
    <style>
        :root {
            --bg-app: #F5F6F8;
            --bg-panel: #FFFFFF;
            --bg-canvas: #EDEEF0;
            --primary: #3B82F6;
            --primary-hover: #2563EB;
            --text-main: #1F2937;
            --text-sub: #6B7280;
            --border: #E5E7EB;
            --radius-md: 8px;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            --selection: rgba(59, 130, 246, 0.1);
            --warning-bg: #FFFBEB;
            --warning-border: #FDE68A;
            --warning-text: #92400E;
            --workspace-offset-left: 288px;
            --workspace-padding-right: 0px;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg-app: #111827;
                --bg-panel: #1F2937;
                --bg-canvas: #0F172A;
                --text-main: #F3F4F6;
                --text-sub: #9CA3AF;
                --border: #374151;
                --selection: rgba(59, 130, 246, 0.2);
                --warning-bg: #451a03;
                --warning-border: #92400e;
                --warning-text: #fef3c7;
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            outline: none;
        }

        body {
            font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Apple SD Gothic Neo', 'Noto Sans KR', 'Malgun Gothic', sans-serif;
            background: var(--bg-app);
            color: var(--text-main);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
        }

        /* --- Custom Professional Cursors --- */
        .cursor-default {
            cursor: default;
        }

        .cursor-pointer {
            cursor: pointer;
        }

        .cursor-grab {
            cursor: url("data:image/svg+xml,%3Csvg width='32' height='32' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M7 10.5V6.5C7 5.67157 7.67157 5 8.5 5C9.32843 5 10 5.67157 10 6.5V10.5M10 10.5V4.5C10 3.67157 10.6716 3 11.5 3C12.3284 3 13 3.67157 13 4.5V10.5M13 10.5V5.5C13 4.67157 13.6716 4 14.5 4C15.3284 4 16 4.67157 16 5.5V10.5M16 10.5V7.5C16 6.66667 16.6667 6 17.5 6C18.3333 6 19 6.66667 19 7.5V14.5C19 18.0899 16.0899 21 12.5 21C8.91015 21 6 18.0899 6 14.5V11.5C6 10.6667 6.66667 10 7.5 10C8.33333 10 9 10.6667 9 11.5V14.5' stroke='white' stroke-width='3' stroke-linecap='round' stroke-linejoin='round'/%3E%3Cpath d='M7 10.5V6.5C7 5.67157 7.67157 5 8.5 5C9.32843 5 10 5.67157 10 6.5V10.5M10 10.5V4.5C10 3.67157 10.6716 3 11.5 3C12.3284 3 13 3.67157 13 4.5V10.5M13 10.5V5.5C13 4.67157 13.6716 4 14.5 4C15.3284 4 16 4.67157 16 5.5V10.5M16 10.5V7.5C16 6.66667 16.6667 6 17.5 6C18.3333 6 19 6.66667 19 7.5V14.5C19 18.0899 16.0899 21 12.5 21C8.91015 21 6 18.0899 6 14.5V11.5C6 10.6667 6.66667 10 7.5 10C8.33333 10 9 10.6667 9 11.5V14.5' stroke='black' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E") 12 12, auto;
        }

        .cursor-grabbing {
            cursor: url("data:image/svg+xml,%3Csvg width='32' height='32' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M7.5 13.5V11.5C7.5 10.6667 8.16667 10 9 10C9.83333 10 10.5 10.6667 10.5 11.5V13.5M10.5 13.5V11.5C10.5 10.6667 11.1667 10 12 10C12.8333 10 13.5 10.6667 13.5 11.5V13.5M13.5 13.5V11.5C13.5 10.6667 14.1667 10 15 10C15.8333 10 16.5 10.6667 16.5 11.5V13.5M16.5 13.5V11.5C16.5 10.6667 17.1667 10 18 10C18.8333 10 19.5 10.6667 19.5 11.5V15.5C19.5 19.0899 16.5899 22 13 22C9.41015 22 6.5 19.0899 6.5 15.5V14.5C6.5 13.6667 7.16667 13 8 13C8.83333 13 9.5 13.6667 9.5 14.5V15.5' stroke='white' stroke-width='3' stroke-linecap='round' stroke-linejoin='round'/%3E%3Cpath d='M7.5 13.5V11.5C7.5 10.6667 8.16667 10 9 10C9.83333 10 10.5 10.6667 10.5 11.5V13.5M10.5 13.5V11.5C10.5 10.6667 11.1667 10 12 10C12.8333 10 13.5 10.6667 13.5 11.5V13.5M13.5 13.5V11.5C13.5 10.6667 14.1667 10 15 10C15.8333 10 16.5 10.6667 16.5 11.5V13.5M16.5 13.5V11.5C16.5 10.6667 17.1667 10 18 10C18.8333 10 19.5 10.6667 19.5 11.5V15.5C19.5 19.0899 16.5899 22 13 22C9.41015 22 6.5 19.0899 6.5 15.5V14.5C6.5 13.6667 7.16667 13 8 13C8.83333 13 9.5 13.6667 9.5 14.5V15.5' stroke='black' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E") 12 12, grabbing;
        }

        .container {
            display: flex;
            height: 100vh;
            width: 100vw;
        }

        /* --- Sidebar & Panels --- */
        .sidebar {
            width: 280px;
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            z-index: 10;
        }

        .sidebar-right {
            border-left: 1px solid var(--border);
            border-right: none;
        }

        .sidebar-header {
            padding: 0 16px;
            border-bottom: 1px solid var(--border);
            font-weight: 600;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: 52px;
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        /* --- Tabs --- */
        .tab-buttons {
            display: flex;
            padding: 4px;
            background: var(--bg-app);
            margin: 12px;
            border-radius: var(--radius-md);
        }

        .tab-btn {
            flex: 1;
            padding: 6px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-weight: 500;
            font-size: 12px;
            color: var(--text-sub);
            border-radius: 6px;
            transition: all 0.2s;
        }

        .tab-btn.active {
            background: var(--bg-panel);
            color: var(--text-main);
            box-shadow: var(--shadow-sm);
        }

        /* --- Canvas Area --- */
        .canvas-area {
            flex: 1;
            position: relative;
            background: var(--bg-canvas);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .canvas-wrapper {
            flex: 1;
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: relative;
        }

        .canvas-wrapper canvas {
            border: none !important;
            outline: none !important;
        }

        /* --- Toolbar --- */
        .top-toolbar {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-panel);
            padding: 8px 16px;
            border-radius: 50px;
            box-shadow: var(--shadow-md);
            display: flex;
            align-items: center;
            gap: 16px;
            z-index: 100;
            border: 1px solid var(--border);
        }

        .action-btn {
            border: none;
            background: transparent;
            cursor: pointer;
            padding: 6px;
            border-radius: 6px;
            color: var(--text-sub);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .action-btn:hover {
            background: var(--bg-app);
            color: var(--text-main);
        }

        /* --- Components --- */
        .section-title {
            font-size: 11px;
            font-weight: 700;
            color: var(--text-sub);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 12px;
            margin-top: 24px;
        }

        .section-title:first-child {
            margin-top: 0;
        }

        .size-presets {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 12px;
        }

        .preset-card {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            padding: 12px;
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: 0.15s;
        }

        .preset-card:hover {
            border-color: var(--primary);
        }

        .preset-card.active {
            border-color: var(--primary);
            background: var(--selection);
        }

        .preset-name {
            display: block;
            font-size: 12px;
            font-weight: 600;
        }

        .preset-dim {
            display: block;
            font-size: 10px;
            color: var(--text-sub);
            margin-top: 2px;
        }

        .custom-size-group {
            display: flex;
            gap: 8px;
            align-items: center;
            padding: 8px 0;
            margin-top: 8px;
        }

        .size-input {
            width: 100%;
            padding: 6px;
            border: 1px solid var(--border);
            border-radius: 4px;
            font-size: 12px;
            background: var(--bg-panel);
            text-align: center;
        }

        .tool-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .tool-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 12px 4px;
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            background: var(--bg-panel);
            cursor: pointer;
            font-size: 11px;
            font-weight: 500;
            gap: 6px;
            color: var(--text-main);
            transition: all 0.2s;
        }

        .tool-btn svg {
            width: 20px;
            height: 20px;
        }

        .tool-btn:hover {
            border-color: var(--primary);
            background: var(--selection);
        }

        /* --- Properties Panels --- */
        .panel-section {
            margin-bottom: 24px;
            border-bottom: 1px solid var(--border);
            padding-bottom: 20px;
        }

        .panel-section:last-child {
            border-bottom: none;
        }

        .panel-title {
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--text-main);
        }

        .property-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            gap: 12px;
        }

        .property-label {
            font-size: 12px;
            color: var(--text-sub);
            width: 64px;
            flex-shrink: 0;
        }

        input[type="text"],
        input[type="number"],
        select {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 13px;
            background: var(--bg-app);
            color: var(--text-main);
        }

        .color-input-grid {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
        }

        input[type="color"] {
            -webkit-appearance: none;
            appearance: none;
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 6px;
            cursor: pointer;
            background: none;
            padding: 0;
            border: 1px solid var(--border);
        }

        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 2px;
        }

        input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 4px;
        }

        .align-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 4px;
            margin-bottom: 8px;
        }

        .align-btn {
            aspect-ratio: 1 / 1;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid transparent;
            background: transparent;
            border-radius: 4px;
            cursor: pointer;
            color: var(--text-main);
            transition: all 0.15s;
            padding: 6px;
        }

        .align-btn:hover {
            background: var(--bg-app);
            border-color: var(--border);
        }

        .align-btn svg {
            width: 18px;
            height: 18px;
            stroke-width: 1.5;
        }

        /* --- XD-Style Alignment UI --- */
        .xd-align-container {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 6px 0;
        }

        .xd-align-btn {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            background: transparent;
            border-radius: 4px;
            cursor: pointer;
            color: var(--text-sub);
            transition: all 0.15s;
            padding: 0;
        }

        .xd-align-btn:hover {
            background: var(--bg-panel);
            color: var(--text-main);
        }

        .xd-align-btn svg {
            width: 16px;
            height: 16px;
            stroke-width: 1.8;
        }

        .xd-divider {
            width: 1px;
            height: 20px;
            background: var(--border);
            margin: 0 4px;
        }

        /* --- Professional Thin Sliders --- */
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 2px;
            background: #E5E7EB;
            border-radius: 1px;
            outline: none;
            margin: 10px 0;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: white;
            border: 2px solid var(--primary);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            transition: all 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        /* --- Collapsible Sections (Figma Style) --- */
        .collapsible-section {
            margin-bottom: 16px;
        }

        .collapsible-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.15s;
            user-select: none;
        }

        .collapsible-header:hover {
            background: var(--bg-app);
        }

        .collapsible-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-sub);
        }

        .collapsible-icon {
            width: 12px;
            height: 12px;
            transition: transform 0.2s;
            color: var(--text-sub);
        }

        .collapsible-icon.collapsed {
            transform: rotate(-90deg);
        }

        .collapsible-content {
            padding: 8px 0;
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease;
        }

        .collapsible-content.collapsed {
            max-height: 0 !important;
            opacity: 0;
            padding: 0;
        }

        /* --- Layers (Figma Style) --- */
        .layer-item {
            display: flex;
            align-items: center;
            padding: 6px 8px;
            border-radius: 4px;
            cursor: pointer;
            margin-bottom: 2px;
            font-size: 11px;
            transition: all 0.15s;
            gap: 8px;
        }

        .layer-item:hover {
            background: var(--bg-app);
        }

        .layer-item.active {
            background: #E3F2FD;
            color: var(--primary);
        }

        .layer-name {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 11px;
        }

        .layer-icon {
            width: 16px;
            height: 16px;
            flex-shrink: 0;
            color: var(--text-sub);
        }

        .layer-icon svg {
            width: 100%;
            height: 100%;
        }

        .layer-actions {
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .layer-item:hover .layer-actions,
        .layer-item.active .layer-actions {
            opacity: 1;
        }

        .layer-action-btn {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            color: var(--text-sub);
            cursor: pointer;
            transition: all 0.15s;
        }

        .layer-action-btn svg {
            width: 14px;
            height: 14px;
        }

        .layer-action-btn:hover {
            color: var(--primary);
            background: var(--bg-panel);
        }

        /* --- Bottom Toolbar (Figma Style) --- */
        .bottom-toolbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 2px;
            background: white;
            border-radius: 8px;
            padding: 6px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.12), 0 0 0 1px rgba(0, 0, 0, 0.05);
            z-index: 100;
        }

        .figma-tool-btn {
            position: relative;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            background: transparent;
            border-radius: 4px;
            cursor: pointer;
            color: var(--text-main);
            transition: all 0.15s;
        }

        .figma-tool-btn svg {
            width: 16px;
            height: 16px;
        }

        .figma-tool-btn:hover {
            background: var(--bg-app);
        }

        .figma-tool-btn.active {
            background: var(--selection);
            color: var(--primary);
        }

        .figma-tool-btn .dropdown-indicator {
            position: absolute;
            bottom: 3px;
            right: 3px;
            width: 0;
            height: 0;
            border-left: 3px solid transparent;
            border-right: 3px solid transparent;
            border-top: 3px solid currentColor;
        }

        .tool-dropdown {
            position: absolute;
            bottom: 100%;
            left: 0;
            margin-bottom: 4px;
            background: white;
            border-radius: 6px;
            padding: 4px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15), 0 0 0 1px rgba(0, 0, 0, 0.05);
            display: none;
            flex-direction: column;
            gap: 2px;
            min-width: 140px;
            z-index: 1000;
        }

        .tool-dropdown.show {
            display: flex;
        }

        .tool-dropdown-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.15s;
            color: var(--text-main);
        }

        .tool-dropdown-item svg {
            width: 16px;
            height: 16px;
        }

        .tool-dropdown-item:hover {
            background: var(--bg-app);
        }

        .toolbar-divider {
            width: 1px;
            height: 24px;
            background: var(--border);
            margin: 0 4px;
        }

        /* --- Left Vertical Toolbar (XD/Figma Style) --- */
        .left-toolbar {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 48px;
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            box-shadow: none;
            display: flex;
            flex-direction: column;
            padding: 8px 0;
            gap: 4px;
            z-index: 100;
        }

        .left-toolbar-btn {
            position: relative;
            width: 32px;
            height: 32px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            background: transparent;
            border-radius: 6px;
            cursor: pointer;
            color: var(--text-sub);
            transition: all 0.15s;
        }

        .left-toolbar-btn svg {
            width: 18px;
            height: 18px;
        }

        .left-toolbar-btn:hover {
            background: var(--bg-app);
            color: var(--text-main);
        }

        .left-toolbar-btn.active {
            background: var(--selection);
            color: var(--primary);
        }

        .left-toolbar-divider {
            width: 24px;
            height: 1px;
            background: var(--border);
            margin: 4px auto;
        }

        .left-toolbar-spacer {
            flex: 1;
        }

        /* --- Layer Panel (Always Visible) --- */
        .layer-panel-fixed {
            position: absolute;
            left: 48px;
            top: 0;
            bottom: 0;
            width: 240px;
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            box-shadow: none;
            display: flex;
            flex-direction: column;
            z-index: 100;
        }

        .layer-panel-header {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            font-weight: 600;
            font-size: 12px;
            color: var(--text-main);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .panel-close-btn {
            border: none;
            background: var(--bg-app);
            color: var(--text-sub);
            border-radius: 6px;
            padding: 6px 10px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.15s;
            display: none;
        }

        .panel-close-btn:hover {
            color: var(--text-main);
            background: var(--bg-panel);
            box-shadow: var(--shadow-sm);
        }

        .layer-panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .preset-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            color: var(--text-main);
            transition: all 0.15s;
            margin-bottom: 2px;
        }

        .preset-item:hover {
            background: var(--bg-app);
        }

        .preset-item.active {
            background: var(--selection);
            color: var(--primary);
        }

        .preset-name {
            font-weight: 500;
        }

        .preset-size {
            font-size: 10px;
            color: var(--text-sub);
        }

        .preset-category {
            padding: 8px 12px 4px 12px;
            font-size: 10px;
            font-weight: 600;
            color: var(--text-sub);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 16px;
            color: white;
            backdrop-filter: blur(4px);
        }

        .loading.show {
            display: flex;
        }

        /* --- Professional Color Picker --- */
        .color-swatch-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
        }

        .color-swatch {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: 1px solid var(--border);
            cursor: pointer;
            flex-shrink: 0;
            box-shadow: var(--shadow-sm);
            transition: transform 0.1s;
        }

        .color-swatch:hover {
            transform: scale(1.1);
        }

        .picker-popover {
            position: absolute;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
            padding: 12px;
            z-index: 1000;
            width: 240px;
            display: none;
            flex-direction: column;
            gap: 12px;
            user-select: none;
        }

        .picker-popover.show {
            display: flex;
        }

        .picker-canvas-area {
            position: relative;
            width: 100%;
            height: 150px;
            border-radius: 4px;
            overflow: hidden;
            cursor: crosshair;
        }

        .picker-hue-slider,
        .picker-alpha-slider {
            width: 100%;
            height: 12px;
            border-radius: 6px;
            position: relative;
            cursor: pointer;
        }

        .picker-alpha-slider {
            background-image: linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%);
            background-size: 8px 8px;
            background-position: 0 0, 0 4px, 4px 4px, 4px 0;
        }

        .picker-inputs {
            display: flex;
            gap: 8px;
        }

        .picker-input-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .picker-input-group label {
            font-size: 10px;
            color: var(--text-sub);
            text-transform: uppercase;
        }

        .picker-input {
            width: 100%;
            padding: 4px 6px;
            border: 1px solid var(--border);
            border-radius: 4px;
            font-size: 11px;
            background: var(--bg-app);
            color: var(--text-main);
            text-align: center;
        }

        .cmyk-grid {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
        }

        .cmyk-input-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .cmyk-input-group label {
            font-size: 11px;
            color: var(--text-sub);
            text-transform: uppercase;
            width: 12px;
            font-weight: 600;
        }

        .cmyk-slider {
            flex: 1;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(to right, #fff 0%, #000 100%);
            border-radius: 2px;
            outline: none;
        }

        .cmyk-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: #fff;
            border: 2px solid #666;
            border-radius: 50%;
            cursor: pointer;
        }

        .cmyk-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: #fff;
            border: 2px solid #666;
            border-radius: 50%;
            cursor: pointer;
        }

        .cmyk-value {
            width: 40px;
            text-align: right;
            font-size: 11px;
            padding: 2px 4px;
            border: 1px solid var(--border);
            border-radius: 3px;
            background: var(--bg-main);
        }

        .color-palette {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            padding-top: 8px;
            border-top: 1px solid var(--border);
        }

        .palette-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid var(--border);
            cursor: pointer;
        }

        .palette-title {
            font-size: 10px;
            color: var(--text-sub);
            font-weight: 600;
            text-transform: uppercase;
            width: 100%;
        }

        /* --- Boundary Warning --- */
        .boundary-warning {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--warning-bg);
            border: 1px solid var(--warning-border);
            padding: 8px 16px;
            border-radius: 8px;
            box-shadow: var(--shadow-md);
            display: none;
            align-items: center;
            gap: 12px;
            z-index: 150;
            color: var(--warning-text);
            font-size: 13px;
            font-weight: 500;
        }

        .boundary-warning.show {
            display: flex;
        }

        .warning-btn {
            background: #F59E0B;
            color: white;
            border: none;
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
        }

        .warning-btn:hover {
            background: #D97706;
        }

        /* --- Floating Toolbar --- */
        .floating-toolbar {
            position: absolute;
            display: none;
            background: white;
            border-radius: 8px;
            padding: 6px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.12), 0 0 0 1px rgba(0, 0, 0, 0.05);
            z-index: 200;
            gap: 2px;
            pointer-events: auto;
            flex-direction: row;
        }

        .floating-toolbar.show {
            display: flex;
        }

        .floating-btn {
            width: 32px;
            height: 32px;
            border-radius: 4px;
            border: none;
            background: transparent;
            color: var(--text-main);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }

        .floating-btn:hover {
            background: var(--bg-app);
        }

        .floating-btn svg {
            width: 16px;
            height: 16px;
        }

        .floating-divider {
            width: 1px;
            height: 24px;
            background: var(--border);
            margin: 0 4px;
        }

        /* --- Custom Scrollbar --- */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-sub);
        }
    </style>
</head>

<body class="cursor-default">
    <div class="loading" id="loading">처리 중...</div>

    <div class="container">
        <!-- Image upload input (hidden) -->
        <input type="file" id="img-upload" style="display: none;" accept="image/*,.svg,.pdf,.ai" onchange="handleImageUpload(this)">

        <!-- Canvas Area -->
        <main class="canvas-area">
            <!-- Left Vertical Toolbar -->
            <div class="left-toolbar">
                <!-- Artboard Tool -->
                <button class="left-toolbar-btn" id="artboard-tool-btn" onclick="selectTool('artboard')" title="아트보드 (A)">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="3" y="3" width="18" height="18" rx="2" />
                        <line x1="3" y1="9" x2="21" y2="9" />
                        <line x1="9" y1="21" x2="9" y2="9" />
                    </svg>
                </button>

                <div class="left-toolbar-divider"></div>

                <!-- Text Tool -->
                <button class="left-toolbar-btn" id="text-tool-btn" onclick="selectTool('text')" title="텍스트 (T)">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M4 7V4h16v3M9 20h6M12 4v16" />
                    </svg>
                </button>

                <!-- Rectangle Tool -->
                <button class="left-toolbar-btn" id="rect-tool-btn" onclick="selectTool('rect')" title="사각형 (R)">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="3" y="3" width="18" height="18" rx="2" />
                    </svg>
                </button>

                <!-- Circle Tool -->
                <button class="left-toolbar-btn" id="circle-tool-btn" onclick="selectTool('circle')" title="원형 (O)">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10" />
                    </svg>
                </button>

                <!-- Triangle Tool -->
                <button class="left-toolbar-btn" id="triangle-tool-btn" onclick="selectTool('triangle')" title="삼각형">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 3l9 18H3L12 3z" />
                    </svg>
                </button>

                <!-- Star Tool -->
                <button class="left-toolbar-btn" id="star-tool-btn" onclick="selectTool('star')" title="별">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" />
                    </svg>
                </button>

                <div class="left-toolbar-divider"></div>

                <!-- Line Tool -->
                <button class="left-toolbar-btn" id="line-tool-btn-left" onclick="selectTool('line')" title="라인 (L)">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="6" y1="18" x2="18" y2="6" stroke-linecap="round" />
                    </svg>
                </button>

                <!-- Arrow Tool -->
                <button class="left-toolbar-btn" id="arrow-tool-btn" onclick="selectTool('arrow')" title="화살표">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M6 18l8-8" stroke-linecap="round" />
                        <path d="M11 6h7v7" stroke-linecap="round" stroke-linejoin="round" />
                    </svg>
                </button>

                <div class="left-toolbar-divider"></div>

                <!-- Image Tool -->
                <button class="left-toolbar-btn" id="image-tool-btn" onclick="selectTool('image')" title="이미지 (I)">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="3" y="3" width="18" height="18" rx="2" />
                        <circle cx="8.5" cy="8.5" r="1.5" />
                        <path d="M21 15l-5-5L5 21" />
                    </svg>
                </button>

                <!-- Spacer -->
                <div class="left-toolbar-spacer"></div>

                <!-- Export Button (at bottom) -->
                <button class="left-toolbar-btn export-btn" onclick="exportToPDF()" title="PDF로 내보내기">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M7 10l5 5 5-5M12 15V3" />
                    </svg>
                </button>
            </div>

            <!-- Layer Panel (Always Visible) -->
            <div class="layer-panel-fixed" id="layer-panel-fixed">
            <div class="layer-panel-header">
                <span id="layer-panel-title">레이어</span>
                <button id="panel-close-btn" class="panel-close-btn" onclick="exitArtboardMode()">닫기</button>
            </div>
                <div class="layer-panel-content" id="layer-panel-fixed-content">
                    <!-- Print Size Presets (shown when artboard selected) -->
                    <div id="print-presets-section" style="display: none;">
                        <div class="preset-category">인쇄 규격</div>
                        <div class="preset-item active" onclick="applyPreset(210, 297, 'A4')">
                            <span class="preset-name">A4</span>
                            <span class="preset-size">210 × 297</span>
                        </div>
                        <div class="preset-item" onclick="applyPreset(297, 420, 'A3')">
                            <span class="preset-name">A3</span>
                            <span class="preset-size">297 × 420</span>
                        </div>
                        <div class="preset-item" onclick="applyPreset(148, 210, 'A5')">
                            <span class="preset-name">A5</span>
                            <span class="preset-size">148 × 210</span>
                        </div>

                        <div class="preset-category">명함 / 카드</div>
                        <div class="preset-item" onclick="applyPreset(90, 50, '명함 (일반)')">
                            <span class="preset-name">명함 (일반)</span>
                            <span class="preset-size">90 × 50</span>
                        </div>
                        <div class="preset-item" onclick="applyPreset(86, 54, '신용카드')">
                            <span class="preset-name">신용카드</span>
                            <span class="preset-size">86 × 54</span>
                        </div>

                        <div class="preset-category">포스터</div>
                        <div class="preset-item" onclick="applyPreset(420, 594, 'A2')">
                            <span class="preset-name">A2</span>
                            <span class="preset-size">420 × 594</span>
                        </div>
                        <div class="preset-item" onclick="applyPreset(594, 841, 'A1')">
                            <span class="preset-name">A1</span>
                            <span class="preset-size">594 × 841</span>
                        </div>
                        <div class="preset-item" onclick="applyPreset(500, 700, '포스터 (일반)')">
                            <span class="preset-name">포스터 (일반)</span>
                            <span class="preset-size">500 × 700</span>
                        </div>

                        <div class="preset-category">배너</div>
                        <div class="preset-item" onclick="applyPreset(600, 1800, '세로 배너')">
                            <span class="preset-name">세로 배너</span>
                            <span class="preset-size">600 × 1800</span>
                        </div>
                        <div class="preset-item" onclick="applyPreset(5000, 900, '가로 배너')">
                            <span class="preset-name">가로 배너</span>
                            <span class="preset-size">5000 × 900</span>
                        </div>
                    </div>

                    <!-- Regular Layer List (shown by default) -->
                    <div id="regular-layer-list">
                        <!-- Layer list will be dynamically populated here -->
                    </div>
                </div>
            </div>

            <div id="boundary-warning" class="boundary-warning">
                <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                    <path
                        d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z" />
                    <line x1="12" y1="9" x2="12" y2="13" />
                    <line x1="12" y1="17" x2="12.01" y2="17" />
                </svg>
                <span>인쇄 영역을 벗어난 개체가 있습니다.</span>
                <button class="warning-btn" onclick="selectOutsideObjects()">확인 및 선택</button>
            </div>

            <div class="canvas-wrapper" id="canvas-container">
                <canvas id="editor-canvas"></canvas>

                <!-- Canvas size info -->
                <div id="canvas-info-bar"
                    style="position: absolute; top: 12px; left: calc(var(--workspace-offset-left) + 12px); background: #1F2937; color: #fff; font-size: 11px; z-index: 100; pointer-events: none; font-weight: 500; padding: 6px 12px; border-radius: 6px;">
                    <span id="canvas-size-label">Size : 90 × 50 mm</span><span id="image-info-label"></span>
                </div>
                <!-- Eyedropper magnifier -->
                <div id="eyedropper-magnifier" style="display: none; position: absolute; width: 96px; height: 96px; border: 2px solid #d1d5db; border-radius: 48px; box-shadow: 0 2px 8px rgba(0,0,0,0.25); pointer-events: none; z-index: 10000; background: #fff;">
                    <div style="position: relative; width: 100%; height: 100%; border-radius: 48px; overflow: hidden;">
                        <canvas id="magnifier-canvas" width="96" height="96" style="display: block;"></canvas>
                        <!-- Crosshairs on top of canvas -->
                        <div style="position: absolute; left: 50%; top: 0; width: 1.5px; height: 100%; background: #fff; transform: translateX(-50%); box-shadow: 0 0 1px rgba(0,0,0,0.35);"></div>
                        <div style="position: absolute; left: 0; top: 50%; width: 100%; height: 1.5px; background: #fff; transform: translateY(-50%); box-shadow: 0 0 1px rgba(0,0,0,0.35);"></div>
                        <!-- Center dot -->
                        <div style="position: absolute; left: 50%; top: 50%; width: 6px; height: 6px; background: #fff; border: 1.5px solid #000; border-radius: 3px; transform: translate(-50%, -50%); box-shadow: 0 0 2px rgba(0,0,0,0.35);"></div>
                    </div>
                </div>

                <!-- Bottom Toolbar (Figma Style) -->
                <div class="bottom-toolbar">
                <!-- Undo/Redo -->
                <button class="figma-tool-btn" onclick="undo()" title="실행 취소 (Ctrl+Z)">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M3 7v6h6" />
                        <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13" />
                    </svg>
                </button>
                <button class="figma-tool-btn" onclick="redo()" title="다시 실행 (Ctrl+Shift+Z)">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 7v6h-6" />
                        <path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3l3 2.7" />
                    </svg>
                </button>

                <div class="toolbar-divider"></div>

                <!-- Zoom Controls -->
                <div style="position: relative; display: flex; align-items: center; background: var(--bg-app); border-radius: 6px; padding: 4px 10px; border: 1px solid var(--border);">
                    <input type="text" id="zoom-input-bottom" value="100%"
                        style="width: 55px; border: none; background: transparent; font-size: 12px; font-weight: 600; text-align: center; color: var(--text-main); outline: none;"
                        onkeydown="if(event.key === 'Enter') handleZoomInput(this.value)"
                        onblur="handleZoomInput(this.value)">
                </div>
                <button class="figma-tool-btn" onclick="fitToScreen()" title="화면에 맞춤">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3" />
                    </svg>
                </button>

                <!-- Object Context Actions (shown when object is selected) -->
                <div id="object-context-tools" style="display: none;">
                    <div class="toolbar-divider"></div>

                    <button class="figma-tool-btn" onclick="duplicateSelected()" title="복제">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="9" y="9" width="13" height="13" rx="2" ry="2" />
                            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" />
                        </svg>
                    </button>

                    <div class="toolbar-divider"></div>

                    <button class="figma-tool-btn" onclick="moveLayerAction('up')" title="앞으로">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M12 5v14" />
                            <path d="M8 9l4-4 4 4" />
                        </svg>
                    </button>
                    <button class="figma-tool-btn" onclick="moveLayerAction('down')" title="뒤로">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M12 19V5" />
                            <path d="M16 15l-4 4-4-4" />
                        </svg>
                    </button>
                    <button class="figma-tool-btn" onclick="moveLayerAction('front')" title="맨 앞으로">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="12" y1="5" x2="12" y2="17" />
                            <path d="M8 9l4-4 4 4" />
                            <line x1="6" y1="19" x2="18" y2="19" />
                        </svg>
                    </button>
                    <button class="figma-tool-btn" onclick="moveLayerAction('back')" title="맨 뒤로">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="12" y1="7" x2="12" y2="19" />
                            <path d="M16 15l-4 4-4-4" />
                            <line x1="6" y1="5" x2="18" y2="5" />
                        </svg>
                    </button>

                    <div class="toolbar-divider"></div>

                    <button class="figma-tool-btn" id="btn-group" onclick="groupSelected()" title="그룹화" style="display:none;">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M3 3h7v7H3z" />
                            <path d="M14 3h7v7h-7z" />
                            <path d="M14 14h7v7h-7z" />
                            <path d="M3 14h7v7H3z" />
                        </svg>
                    </button>
                    <button class="figma-tool-btn" id="btn-ungroup" onclick="ungroupSelected()" title="그룹 해제" style="display:none;">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M12 3v18" />
                            <path d="M3 12h18" />
                        </svg>
                    </button>
                    <button class="figma-tool-btn" id="btn-mask" onclick="maskWithShape()" title="마스크 적용" style="display:none;">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="3" y="3" width="18" height="18" rx="2" />
                            <circle cx="12" cy="12" r="5" />
                        </svg>
                    </button>
                    <button class="figma-tool-btn" id="btn-unmask" onclick="releaseMask()" title="마스크 해제" style="display:none;">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M7 21v-2a4 4 0 0 1 4-4h2a4 4 0 0 1 4 4v2" />
                            <circle cx="12" cy="7" r="4" />
                        </svg>
                    </button>

                    <div class="toolbar-divider"></div>

                    <button class="figma-tool-btn" onclick="flipHorizontal()" title="가로 뒤집기">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="12" y1="4.5" x2="12" y2="19.5" stroke-dasharray="2 2" />
                            <path d="M3.75 6.5 L9.5 9.75 L9.5 14.25 L3.75 17.5 Z" />
                            <path d="M20.25 6.5 L14.5 9.75 L14.5 14.25 L20.25 17.5 Z" />
                        </svg>
                    </button>
                    <button class="figma-tool-btn" onclick="flipVertical()" title="세로 뒤집기">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="4.5" y1="12" x2="19.5" y2="12" stroke-dasharray="2 2" />
                            <path d="M6.5 4.75 L9.75 10.5 L14.25 10.5 L17.5 4.75 Z" />
                            <path d="M6.5 19.25 L9.75 13.5 L14.25 13.5 L17.5 19.25 Z" />
                        </svg>
                    </button>
                    <button class="figma-tool-btn" onclick="rotateCCW()" title="90° 반시계 회전">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M4 12a8 8 0 1 0 8-8" />
                            <path d="M8 4H4v4" />
                        </svg>
                    </button>
                    <button class="figma-tool-btn" onclick="rotateCW()" title="90° 시계 회전">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M20 12a8 8 0 1 1-8-8" />
                            <path d="M16 4h4v4" />
                        </svg>
                    </button>
                    <button class="figma-tool-btn" onclick="rotate180()" title="180° 회전">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M7 7a8 8 0 1 1 0 10" />
                            <path d="M7 3v4H3" />
                        </svg>
                    </button>

                    <div class="toolbar-divider"></div>

                    <button class="figma-tool-btn" onclick="lockSelectedAction()" title="잠금">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="3" y="11" width="18" height="11" rx="2" ry="2" />
                            <path d="M7 11V7a5 5 0 0 1 10 0v4" />
                        </svg>
                    </button>
                    <button class="figma-tool-btn" onclick="unlockSelectedAction()" title="잠금 해제">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="3" y="11" width="18" height="11" rx="2" ry="2" />
                            <path d="M7 11V7a5 5 0 0 1 9.9-1" />
                        </svg>
                    </button>

                    <div class="toolbar-divider"></div>

                    <button class="figma-tool-btn" onclick="deleteSelected()" title="삭제" style="color:#DC2626">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" />
                        </svg>
                    </button>
                </div>
            </div>
            </div>
        </main>

        <!-- 3. 우측 사이드바 -->
        <aside class="sidebar sidebar-right">
            <div class="sidebar-header">속성</div>
            <div class="sidebar-content">
                <!-- 정렬 -->
                <div class="panel-section">
                    <div class="panel-title" style="display: flex; align-items: center; gap: 8px;">
                        <span style="display: inline-flex; align-items: center;">정렬</span>
                    </div>
                    <div class="xd-align-container">
                        <!-- Horizontal Align Group -->
                        <button class="xd-align-btn" onclick="alignObject('left')" title="왼쪽 정렬">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
                                <line x1="3" y1="5" x2="3" y2="19" stroke-width="2"/>
                                <rect x="5" y="7" width="12" height="3" fill="currentColor"/>
                                <rect x="5" y="14" width="8" height="3" fill="currentColor"/>
                            </svg>
                        </button>
                        <button class="xd-align-btn" onclick="alignObject('center')" title="가로 가운데 정렬">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
                                <line x1="12" y1="5" x2="12" y2="19" stroke-width="2"/>
                                <rect x="6" y="7" width="12" height="3" fill="currentColor"/>
                                <rect x="8" y="14" width="8" height="3" fill="currentColor"/>
                            </svg>
                        </button>
                        <button class="xd-align-btn" onclick="alignObject('right')" title="오른쪽 정렬">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
                                <line x1="21" y1="5" x2="21" y2="19" stroke-width="2"/>
                                <rect x="7" y="7" width="12" height="3" fill="currentColor"/>
                                <rect x="11" y="14" width="8" height="3" fill="currentColor"/>
                            </svg>
                        </button>

                        <div class="xd-divider"></div>

                        <!-- Vertical Align Group -->
                        <button class="xd-align-btn" onclick="alignObject('top')" title="상단 정렬">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
                                <line x1="5" y1="3" x2="19" y2="3" stroke-width="2"/>
                                <rect x="7" y="5" width="3" height="12" fill="currentColor"/>
                                <rect x="14" y="5" width="3" height="8" fill="currentColor"/>
                            </svg>
                        </button>
                        <button class="xd-align-btn" onclick="alignObject('middle')" title="세로 가운데 정렬">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
                                <line x1="5" y1="12" x2="19" y2="12" stroke-width="2"/>
                                <rect x="7" y="6" width="3" height="12" fill="currentColor"/>
                                <rect x="14" y="8" width="3" height="8" fill="currentColor"/>
                            </svg>
                        </button>
                        <button class="xd-align-btn" onclick="alignObject('bottom')" title="하단 정렬">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
                                <line x1="5" y1="21" x2="19" y2="21" stroke-width="2"/>
                                <rect x="7" y="7" width="3" height="12" fill="currentColor"/>
                                <rect x="14" y="11" width="3" height="8" fill="currentColor"/>
                            </svg>
                        </button>

                        <div class="xd-divider"></div>

                        <!-- Distribute Group -->
                        <button class="xd-align-btn" onclick="distributeObjects('horizontal')" title="가로 간격 동일하게">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
                                <line x1="4" y1="4" x2="4" y2="20" stroke-width="2"/>
                                <line x1="20" y1="4" x2="20" y2="20" stroke-width="2"/>
                                <rect x="9" y="8" width="2" height="8" fill="currentColor"/>
                                <rect x="13" y="7" width="2" height="10" fill="currentColor"/>
                            </svg>
                        </button>
                        <button class="xd-align-btn" onclick="distributeObjects('vertical')" title="세로 간격 동일하게">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
                                <line x1="4" y1="4" x2="20" y2="4" stroke-width="2"/>
                                <line x1="4" y1="20" x2="20" y2="20" stroke-width="2"/>
                                <rect x="8" y="9" width="8" height="2" fill="currentColor"/>
                                <rect x="7" y="13" width="10" height="2" fill="currentColor"/>
                            </svg>
                        </button>
                    </div>
                </div>

                <!-- 사용자 정의 크기 -->
                <div class="panel-section">
                    <div class="panel-title">사용자 정의 크기</div>
                    <div class="custom-size-group">
                        <div style="flex:1">
                            <label style="font-size: 10px; color: var(--text-sub); margin-bottom: 4px; display: block;">가로 (mm)</label>
                            <input type="number" id="custom-width-input" class="size-input" value="210" onchange="applyCustomSize()">
                        </div>
                        <span style="font-size: 12px; margin-top: 14px;">×</span>
                        <div style="flex:1">
                            <label style="font-size: 10px; color: var(--text-sub); margin-bottom: 4px; display: block;">세로 (mm)</label>
                            <input type="number" id="custom-height-input" class="size-input" value="297" onchange="applyCustomSize()">
                        </div>
                    </div>
                </div>

                <!-- 텍스트 -->
                <div id="prop-text" class="panel-section" style="display: none;">
                    <div class="panel-title">타이포그래피</div>
                    <div class="property-row">
                        <label class="property-label">글꼴</label>
                        <select id="font-family" onchange="updateTypography('fontFamily', this.value)" style="flex: 1;">
                            <option value="Pretendard">Pretendard</option>
                            <option value="Noto Sans KR">Noto Sans KR</option>
                            <option value="Noto Serif KR">Noto Serif KR</option>
                            <option value="Nanum Gothic">Nanum Gothic</option>
                            <option value="Nanum Myeongjo">Nanum Myeongjo</option>
                            <option value="Black Han Sans">Black Han Sans</option>
                            <option value="Do Hyeon">Do Hyeon</option>
                            <option value="Gowun Dodum">Gowun Dodum</option>
                            <option value="Inter">Inter</option>
                            <option value="Roboto">Roboto</option>
                            <option value="Arial">Arial</option>
                            <option value="Georgia">Georgia</option>
                        </select>
                    </div>
                    <div class="property-row">
                        <label class="property-label">크기</label>
                        <input type="number" id="font-size" value="24" min="1" max="500"
                            onchange="updateTypography('fontSize', this.value)" style="width: 60px;">
                        <span style="font-size: 11px; margin-left: 4px;">px</span>
                    </div>
                    <div class="property-row">
                        <label class="property-label">두께</label>
                        <select id="font-weight" onchange="updateTypography('fontWeight', this.value)" style="flex: 1;">
                            <option value="normal">Normal</option>
                            <option value="bold">Bold</option>
                            <option value="100">Thin</option>
                            <option value="300">Light</option>
                            <option value="500">Medium</option>
                            <option value="700">Bold (700)</option>
                            <option value="900">Black</option>
                        </select>
                    </div>
                    <div class="property-row">
                        <div style="flex: 1;">
                            <label class="property-label">행간</label>
                            <input type="number" id="line-height" value="1.2" step="0.1" min="0.5" max="5"
                                onchange="updateTypography('lineHeight', this.value)" style="width: 50px;">
                        </div>
                        <div style="flex: 1;">
                            <label class="property-label">자간</label>
                            <input type="number" id="char-spacing" value="0" step="10"
                                onchange="updateTypography('charSpacing', this.value)" style="width: 50px;">
                        </div>
                    </div>
                    <div class="property-row">
                        <label class="property-label">정렬</label>
                        <div class="align-grid" style="border: none; padding: 0;">
                            <button class="align-btn" onclick="updateTypography('textAlign', 'left')" title="왼쪽">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <line x1="3" y1="7" x2="17" y2="7"/>
                                    <line x1="3" y1="11" x2="21" y2="11"/>
                                    <line x1="3" y1="15" x2="15" y2="15"/>
                                </svg>
                            </button>
                            <button class="align-btn" onclick="updateTypography('textAlign', 'center')" title="가운데">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <line x1="7" y1="7" x2="17" y2="7"/>
                                    <line x1="3" y1="11" x2="21" y2="11"/>
                                    <line x1="9" y1="15" x2="15" y2="15"/>
                                </svg>
                            </button>
                            <button class="align-btn" onclick="updateTypography('textAlign', 'right')" title="오른쪽">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <line x1="7" y1="7" x2="21" y2="7"/>
                                    <line x1="3" y1="11" x2="21" y2="11"/>
                                    <line x1="9" y1="15" x2="21" y2="15"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div style="margin-top: 12px;">
                        <button class="tool-btn" onclick="document.getElementById('font-upload-input').click()"
                            style="width: 100%; font-size: 11px; padding: 6px;">
                            <span>외부 글꼴 업로드 (.ttf, .otf)</span>
                        </button>
                        <input type="file" id="font-upload-input" style="display: none;" accept=".ttf, .otf"
                            onchange="handleFontUpload(this)">
                    </div>
                </div>

                <!-- 채우기 -->
                <div id="prop-fill" class="panel-section" style="display: none;">
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                        <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                            <input type="checkbox" id="fill-enabled" onchange="toggleFillEnabled()" checked style="width: 16px; height: 16px;">
                            <span class="panel-title" style="margin: 0;">채우기</span>
                        </label>
                        <div id="fill-swatch" class="color-swatch" style="background: #3B82F6;"
                            onclick="openPicker('fill', this)"></div>
                        <button onclick="activateEyedropper('fill')" title="스포이드로 색상 추출"
                            style="width: 24px; height: 24px; padding: 4px; border: 1px solid var(--border); border-radius: 4px; background: var(--bg-panel); cursor: pointer; display: flex; align-items: center; justify-content: center;">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M2 22l1-1h3l9-9"></path>
                                <path d="M3 21v-3l9-9"></path>
                                <path d="M15 6l3-3"></path>
                                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L19 8l-3-3 2.5-2.5z"></path>
                            </svg>
                        </button>
                        <label style="font-weight: normal; font-size: 11px; display: flex; align-items: center; gap: 6px; cursor: pointer; margin-left: auto;">
                            <input type="checkbox" id="gradient-check" onchange="toggleGradientMode()" style="width: 14px; height: 14px;">
                            그라데이션
                        </label>
                    </div>
                    <div id="fill-settings">
                        <div id="gradient-panel" style="display: none;">
                            <div class="property-row">
                                <label class="property-label">유형</label>
                                <select id="grad-type" onchange="updateGradientType()">
                                    <option value="linear">선형 (Linear)</option>
                                    <option value="radial">원형 (Radial)</option>
                                </select>
                            </div>
                            <div class="property-row" id="grad-angle-row">
                                <label class="property-label">회전</label>
                                <input type="range" id="grad-angle" min="0" max="360" value="0" oninput="updateGradient()"
                                    style="flex:1">
                                <span id="grad-angle-val" style="font-size: 11px; width: 28px; text-align: right;">0°</span>
                            </div>
                            <div class="property-row">
                                <label class="property-label">시작</label>
                                <div id="grad-start-swatch" class="color-swatch" style="background: #3B82F6;"
                                    onclick="openPicker('grad-start', this)"></div>
                            </div>
                            <div class="property-row">
                                <label class="property-label">종료</label>
                                <div id="grad-end-swatch" class="color-swatch" style="background: #2563EB;"
                                    onclick="openPicker('grad-end', this)"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 테두리 -->
                <div id="prop-stroke" class="panel-section" style="display: none;">
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                        <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                            <input type="checkbox" id="stroke-enabled" onchange="toggleStrokeEnabled()" style="width: 16px; height: 16px;">
                            <span class="panel-title" style="margin: 0;">테두리</span>
                        </label>
                        <div id="stroke-swatch" class="color-swatch" style="background: #000000;"
                            onclick="openPicker('stroke', this)"></div>
                        <button onclick="activateEyedropper('stroke')" title="스포이드로 색상 추출"
                            style="width: 24px; height: 24px; padding: 4px; border: 1px solid var(--border); border-radius: 4px; background: var(--bg-panel); cursor: pointer; display: flex; align-items: center; justify-content: center;">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M2 22l1-1h3l9-9"></path>
                                <path d="M3 21v-3l9-9"></path>
                                <path d="M15 6l3-3"></path>
                                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L19 8l-3-3 2.5-2.5z"></path>
                            </svg>
                        </button>
                    </div>
                    <div id="stroke-settings" style="display: none;">
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <div style="flex: 1; display: flex; flex-direction: column; gap: 2px;">
                                <label style="font-size: 10px; color: var(--text-sub);">크기</label>
                                <input type="number" id="stroke-width-input" min="1" max="100" value="1"
                                    oninput="changeStrokeWidth(this.value)"
                                    style="width: 100%; padding: 4px; border: 1px solid var(--border); border-radius: 4px; font-size: 11px;">
                            </div>
                            <div style="flex: 1; display: flex; flex-direction: column; gap: 2px;">
                                <label style="font-size: 10px; color: var(--text-sub);">길이</label>
                                <input type="number" id="dash-length" value="0" min="0" max="100"
                                    oninput="updateStrokeDash()"
                                    style="width: 100%; padding: 4px; border: 1px solid var(--border); border-radius: 4px; font-size: 11px;">
                            </div>
                            <div style="flex: 1; display: flex; flex-direction: column; gap: 2px;">
                                <label style="font-size: 10px; color: var(--text-sub);">간격</label>
                                <input type="number" id="dash-gap" value="0" min="0" max="100"
                                    oninput="updateStrokeDash()"
                                    style="width: 100%; padding: 4px; border: 1px solid var(--border); border-radius: 4px; font-size: 11px;">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 모서리 곡률 -->
                <div id="prop-corner" class="panel-section" style="display: none;">
                    <div class="panel-title">모서리 곡률</div>
                    <div class="property-row">
                        <label class="property-label">반지름</label>
                        <input type="range" id="corner-radius" min="0" max="100" value="0"
                            oninput="changeCornerRadius(this.value)" style="flex:1">
                        <span id="corner-radius-val" style="font-size: 11px; width: 24px; text-align: right;">0</span>
                    </div>
                </div>

                <!-- 불투명도 -->
                <div id="prop-opacity" class="panel-section">
                    <div class="panel-title">불투명도</div>
                    <div class="property-row">
                        <label class="property-label">투명도</label>
                        <input type="range" id="global-opacity" min="0" max="100" value="100"
                            oninput="changeObjectOpacity(this.value)" onchange="saveHistory()" style="flex:1">
                        <span id="global-opacity-val"
                            style="font-size: 11px; width: 28px; text-align: right;">100</span>
                    </div>
                </div>

                <!-- 그림자 -->
                <div id="prop-shadow" class="panel-section">
                    <div class="panel-title">그림자</div>
                    <div class="property-row">
                        <label class="property-label">
                            <input type="checkbox" id="shadow-enabled" onchange="toggleShadow()" style="margin-right: 4px;">
                            활성화
                        </label>
                    </div>
                    <div id="shadow-settings" style="display: none;">
                        <div class="property-row">
                            <label class="property-label">색상</label>
                            <div id="shadow-color-swatch" class="color-swatch" style="background: rgba(0,0,0,0.5);"
                                onclick="openPicker('shadow', this)"></div>
                        </div>
                        <div class="property-row">
                            <label class="property-label">블러</label>
                            <input type="range" id="shadow-blur" min="0" max="50" value="10"
                                oninput="changeShadowBlur(this.value)" style="flex:1">
                            <span id="shadow-blur-val" style="font-size: 11px; width: 24px; text-align: right;">10</span>
                        </div>
                        <div class="property-row">
                            <label class="property-label">X 거리</label>
                            <input type="range" id="shadow-offset-x" min="-50" max="50" value="5"
                                oninput="changeShadowOffsetX(this.value)" style="flex:1">
                            <span id="shadow-offset-x-val" style="font-size: 11px; width: 24px; text-align: right;">5</span>
                        </div>
                        <div class="property-row">
                            <label class="property-label">Y 거리</label>
                            <input type="range" id="shadow-offset-y" min="-50" max="50" value="5"
                                oninput="changeShadowOffsetY(this.value)" style="flex:1">
                            <span id="shadow-offset-y-val" style="font-size: 11px; width: 24px; text-align: right;">5</span>
                        </div>
                    </div>
                </div>


            </div>
        </aside>
    </div>

    <div id="color-picker" class="picker-popover">
        <div class="picker-canvas-area" id="picker-sb-area">
            <canvas id="picker-sb-canvas"></canvas>
            <div id="picker-sb-cursor"
                style="position: absolute; width: 12px; height: 12px; border: 2px solid white; border-radius: 50%; box-shadow: 0 0 2px rgba(0,0,0,0.5); pointer-events: none; transform: translate(-50%, -50%);">
            </div>
        </div>
        <div class="picker-hue-slider" id="picker-hue-area">
            <canvas id="picker-hue-canvas"></canvas>
            <div id="picker-hue-cursor"
                style="position: absolute; top: -2px; width: 4px; height: 16px; background: white; border: 1px solid rgba(0,0,0,0.2); border-radius: 2px; box-shadow: 0 0 2px rgba(0,0,0,0.5); pointer-events: none; transform: translateX(-50%);">
            </div>
        </div>
        <div class="picker-alpha-slider" id="picker-alpha-area">
            <canvas id="picker-alpha-canvas"></canvas>
            <div id="picker-alpha-cursor"
                style="position: absolute; top: -2px; width: 4px; height: 16px; background: white; border: 1px solid rgba(0,0,0,0.2); border-radius: 2px; box-shadow: 0 0 2px rgba(0,0,0,0.5); pointer-events: none; transform: translateX(-50%);">
            </div>
        </div>
        <div class="picker-inputs">
            <div class="picker-input-group" style="flex: 2;">
                <label>Hex</label>
                <input type="text" id="picker-hex" class="picker-input" spellcheck="false">
            </div>
            <div class="picker-input-group" style="flex: 1;">
                <label>Opacity</label>
                <input type="text" id="picker-opacity" class="picker-input" spellcheck="false">
            </div>
        </div>
        <div class="cmyk-grid">
            <div class="cmyk-input-group">
                <label>C</label>
                <input type="range" id="picker-cmyk-c-slider" class="cmyk-slider" min="0" max="100" value="0">
                <input type="number" id="picker-cmyk-c" class="cmyk-value" min="0" max="100" value="0">
                <span style="font-size: 10px; color: var(--text-sub);">%</span>
            </div>
            <div class="cmyk-input-group">
                <label>M</label>
                <input type="range" id="picker-cmyk-m-slider" class="cmyk-slider" min="0" max="100" value="0">
                <input type="number" id="picker-cmyk-m" class="cmyk-value" min="0" max="100" value="0">
                <span style="font-size: 10px; color: var(--text-sub);">%</span>
            </div>
            <div class="cmyk-input-group">
                <label>Y</label>
                <input type="range" id="picker-cmyk-y-slider" class="cmyk-slider" min="0" max="100" value="0">
                <input type="number" id="picker-cmyk-y" class="cmyk-value" min="0" max="100" value="0">
                <span style="font-size: 10px; color: var(--text-sub);">%</span>
            </div>
            <div class="cmyk-input-group">
                <label>K</label>
                <input type="range" id="picker-cmyk-k-slider" class="cmyk-slider" min="0" max="100" value="0">
                <input type="number" id="picker-cmyk-k" class="cmyk-value" min="0" max="100" value="0">
                <span style="font-size: 10px; color: var(--text-sub);">%</span>
            </div>
        </div>
        <div id="doc-colors" class="color-palette">
            <div class="palette-title">문서 색상</div>
        </div>
    </div>

    <script>
        // --- GLOBAL STATE ---
        let canvas;
        let currentWidth = 210; // mm (A4 default)
        let currentHeight = 297; // mm (A4 default)
        const SCREEN_DPI = 96;
        const PRINT_DPI = 300;
        const MM_TO_PX_SCREEN = SCREEN_DPI / 25.4;
        const MM_TO_PX_PRINT = PRINT_DPI / 25.4;
        const WORKSPACE_OFFSET_LEFT = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--workspace-offset-left')) || 288;
        const WORKSPACE_PADDING_RIGHT = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--workspace-padding-right')) || 24;

        // --- PRINT SAFETY (opentype.js) ---
        const fontCache = new Map();
        async function getOpentypeFont(family) {
            if (fontCache.has(family)) return fontCache.get(family);
            const url = 'https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/packages/pretendard/dist/web/static/woff2/Pretendard-Regular.woff2';
            try {
                const buf = await fetch(url).then(r => r.arrayBuffer());
                const font = opentype.parse(buf);
                fontCache.set(family, font);
                return font;
            } catch (e) { console.error("Font load fail", e); return null; }
        }

        let artboard;
        let workspaceWidth, workspaceHeight;
        let isSpacePressed = false;

        const CURSOR_GRAB = `url("data:image/svg+xml,%3Csvg width='32' height='32' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M14 11V6.5C14 5.67 13.33 5 12.5 5C11.67 5 11 5.67 11 6.5V11.5M11 11.5V3.5C11 2.67 10.33 2 9.5 2C8.67 2 8 2.67 8 3.5V11.5M8 11.5V4.5C8 3.67 7.33 3 6.5 3C5.67 3 5 3.67 5 4.5V11.5M5 11.5V7C5 6.17 4.33 5.5 3.5 5.5C2.67 5.5 2 6.17 2 7V13.5C2 17.09 4.91 20 8.5 20C12.09 20 15 17.09 15 13.5V11' stroke='white' stroke-width='1.5' fill='black'/%3E%3C/svg%3E") 12 12, auto`;
        const CURSOR_GRABBING = `url("data:image/svg+xml,%3Csvg width='32' height='32' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M12 11V9.5C12 8.67 11.33 8 10.5 8C9.67 8 9 8.67 9 9.5V11M9 11V9.5C9 8.67 8.33 8 7.5 8C6.67 8 6 8.67 6 9.5V11M6 11V9.5C6 8.67 5.33 8 4.5 8C3.67 8 3 8.67 3 9.5V11M3 11V9.5C3 8.67 2.33 8 1.5 8C0.67 8 0 8.67 0 9.5V13.5C0 17.09 2.91 20 6.5 20C10.09 20 13 17.09 13 13.5V11' stroke='white' stroke-width='1.5' fill='black'/%3E%3C/svg%3E") 12 12, auto`;

        // Undo/Redo
        let history = [];
        let historyStep = -1;
        let isUndoing = false;

        // Color Picker State
        let pickerTarget = null;
        let pickerHue = 0;
        let pickerSaturation = 1;
        let pickerAlpha = 1;
        let pickerCmyk = { c: 0, m: 0, y: 0, k: 0 };

        // Eyedropper
        let eyedropperActive = false;
        let eyedropperTarget = null;
        let eyedropperSelectedObject = null;

        function activateEyedropper(target) {
            // Store the currently selected object
            eyedropperSelectedObject = canvas.getActiveObject();

            // Require an object to be selected first
            if (!eyedropperSelectedObject) {
                alert('먼저 색상을 적용할 객체를 선택해주세요.');
                return;
            }

            eyedropperActive = true;
            eyedropperTarget = target;
            canvas.defaultCursor = 'none'; // Hide cursor, we'll show magnifier instead
            canvas.hoverCursor = 'none';
            canvas.selection = false;

            // DON'T discard active object - keep panels visible!
            // Just disable interaction temporarily
            canvas.forEachObject(obj => {
                obj.selectable = false;
                obj.evented = false;
            });

            // Show magnifier
            document.getElementById('eyedropper-magnifier').style.display = 'block';

            canvas.renderAll();
        }

        function deactivateEyedropper() {
            eyedropperActive = false;
            eyedropperTarget = null;
            canvas.defaultCursor = 'default';
            canvas.hoverCursor = 'move';
            canvas.selection = true;
            canvas.forEachObject(obj => {
                if (!obj.lockMovementX && !obj.isArtboard) {
                    obj.selectable = true;
                    obj.evented = true;
                }
            });

            // Hide magnifier
            document.getElementById('eyedropper-magnifier').style.display = 'none';

            // Restore the previously selected object
            if (eyedropperSelectedObject) {
                canvas.setActiveObject(eyedropperSelectedObject);
                eyedropperSelectedObject = null;
            }

            canvas.renderAll();
        }

        function getEyedropperCanvasCoords(e) {
            const canvasEl = canvas.lowerCanvasEl;
            const canvasRect = canvasEl.getBoundingClientRect();
            const evt = e.e || e;
            const touch = evt.touches?.[0];
            const clientX = touch?.clientX ?? evt.clientX;
            const clientY = touch?.clientY ?? evt.clientY;

            const scaleX = canvasEl.width / canvasRect.width;
            const scaleY = canvasEl.height / canvasRect.height;

            let x = (clientX - canvasRect.left) * scaleX;
            let y = (clientY - canvasRect.top) * scaleY;

            const vpt = canvas.viewportTransform || [1, 0, 0, 1, 0, 0];
            const panX = vpt[4] || 0;
            const panY = vpt[5] || 0;
            const zoom = canvas.getZoom ? canvas.getZoom() : 1;

            x = (x - panX) / zoom;
            y = (y - panY) / zoom;

            return {
                clientX,
                clientY,
                cssXCanvas: clientX - canvasRect.left,
                cssYCanvas: clientY - canvasRect.top,
                canvasX: Math.floor(x),
                canvasY: Math.floor(y),
                canvasRect
            };
        }

        function updateEyedropperMagnifier(e) {
            if (!eyedropperActive) return;

            const magnifier = document.getElementById('eyedropper-magnifier');
            const magnifierCanvas = document.getElementById('magnifier-canvas');
            const magnifierCtx = magnifierCanvas.getContext('2d');

            const wrapperRect = document.getElementById('canvas-container').getBoundingClientRect();
            const { cssXCanvas, canvasX, canvasY, clientX, clientY } = getEyedropperCanvasCoords(e);
            const cssXWrapper = clientX - wrapperRect.left;
            const cssYWrapper = clientY - wrapperRect.top;

            // Position magnifier near cursor (offset to bottom-right to not block view)
            const magnifierSize = 96;
            const offset = 16;

            let left = cssXWrapper + offset;
            let top = cssYWrapper + offset;

            // Keep magnifier within canvas bounds
            if (left + magnifierSize > wrapperRect.width) {
                left = cssXWrapper - magnifierSize - offset;
            }
            if (top + magnifierSize + 40 > wrapperRect.height) { // +40 for color label
                top = cssYWrapper - magnifierSize - offset;
            }

            magnifier.style.left = left + 'px';
            magnifier.style.top = top + 'px';

            const ctx = canvas.lowerCanvasEl.getContext('2d', { willReadFrequently: true });
            const size = 14; // Sample size in canvas pixels (14x14 grid)
            const sampleWidth = canvas.lowerCanvasEl.width;
            const sampleHeight = canvas.lowerCanvasEl.height;
            const startX = Math.max(0, Math.min(canvasX - Math.floor(size / 2), sampleWidth - size));
            const startY = Math.max(0, Math.min(canvasY - Math.floor(size / 2), sampleHeight - size));

            try {
                // Get image data from canvas at the scaled coordinates
                const imageData = ctx.getImageData(
                    startX,
                    startY,
                    size,
                    size
                );

                // Draw zoomed image on magnifier canvas
                magnifierCtx.imageSmoothingEnabled = false; // Pixelated zoom
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = size;
                tempCanvas.height = size;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.putImageData(imageData, 0, 0);

            magnifierCtx.clearRect(0, 0, magnifierSize, magnifierSize);
            magnifierCtx.drawImage(tempCanvas, 0, 0, size, size, 0, 0, magnifierSize, magnifierSize);
            } catch (err) {
                // Ignore errors from sampling outside canvas
                console.warn('Eyedropper sampling error:', err);
            }
        }

        function sampleColorFromCanvas(e) {
            if (!eyedropperActive) return;

            const { canvasX, canvasY } = getEyedropperCanvasCoords(e);
            const ctx = canvas.lowerCanvasEl.getContext('2d', { willReadFrequently: true });
            const width = canvas.lowerCanvasEl.width;
            const height = canvas.lowerCanvasEl.height;

            // Sample from scaled coordinates
            const clampedX = Math.min(Math.max(0, canvasX), width - 1);
            const clampedY = Math.min(Math.max(0, canvasY), height - 1);
            const pixelData = ctx.getImageData(clampedX, clampedY, 1, 1).data;
            const r = pixelData[0];
            const g = pixelData[1];
            const b = pixelData[2];
            const a = pixelData[3] / 255;

            const color = `rgba(${r}, ${g}, ${b}, ${a})`;
            const targetType = eyedropperTarget; // Store before deactivating

            // Object is still selected, just re-enable interaction
            eyedropperActive = false;
            eyedropperTarget = null;
            canvas.defaultCursor = 'default';
            canvas.hoverCursor = 'move';
            canvas.selection = true;
            canvas.forEachObject(obj => {
                if (!obj.lockMovementX && !obj.isArtboard) {
                    obj.selectable = true;
                    obj.evented = true;
                }
            });

            // Hide magnifier
            document.getElementById('eyedropper-magnifier').style.display = 'none';

            // Apply the color to the selected object (still active)
            if (targetType === 'fill') {
                changeFillColor(color);
            } else if (targetType === 'stroke') {
                changeStrokeColor(color);
            }

            eyedropperSelectedObject = null;
            canvas.renderAll();
        }

        function mmToPx(mm) { return mm * MM_TO_PX_SCREEN; }
        function getWorkspaceCenterX() {
            return WORKSPACE_OFFSET_LEFT + (workspaceWidth - WORKSPACE_OFFSET_LEFT - WORKSPACE_PADDING_RIGHT) / 2;
        }
        function updateWorkspaceUIPositions() {
            const centerX = getWorkspaceCenterX();
            const bottomToolbar = document.querySelector('.bottom-toolbar');
            if (bottomToolbar) bottomToolbar.style.left = `${centerX}px`;
            const topToolbar = document.querySelector('.top-toolbar');
            if (topToolbar) topToolbar.style.left = `${centerX}px`;
            const warning = document.getElementById('boundary-warning');
            if (warning) warning.style.left = `${centerX}px`;
        }

        // --- INIT ---
        let objectIdCounter = 0;

        function ensureObjectId(obj) {
            if (!obj) return;
            if (!obj.customId) {
                objectIdCounter += 1;
                obj.customId = `obj_${Date.now()}_${objectIdCounter}`;
            }
        }
        function initCanvas() {
            const wrapper = document.getElementById('canvas-container');
            workspaceWidth = wrapper.clientWidth;
            workspaceHeight = wrapper.clientHeight;
            updateWorkspaceUIPositions();

            const baseToObject = fabric.Object.prototype.toObject;
            fabric.Object.prototype.toObject = function (propertiesToInclude) {
                const obj = baseToObject.call(this, propertiesToInclude);
                delete obj.clipPath;
                return obj;
            };

            fabric.Image.prototype.toObject = (function (toObject) {
                return function () {
                    return fabric.util.object.extend(toObject.call(this), {
                        src: this.src || (this._originalElement && this._originalElement.src) || null,
                        customId: this.customId || null
                    });
                };
            })(fabric.Image.prototype.toObject);

            fabric.Image.fromObject = function (object, callback) {
                const src = object.src;
                fabric.util.loadImage(src, (img) => {
                    const image = new fabric.Image(img, object);
                    image.src = src;
                    ensureObjectId(image);
                    callback && callback(image);
                }, null, object.crossOrigin || 'anonymous');
            };

            canvas = new fabric.Canvas('editor-canvas', {
                width: workspaceWidth,
                height: workspaceHeight,
                backgroundColor: 'transparent',
                preserveObjectStacking: true,
                fireRightClick: true,
                stopContextMenu: true,
                selection: true,
                selectionColor: 'rgba(59, 130, 246, 0.1)',
                selectionBorderColor: '#3B82F6',
                selectionLineWidth: 1.5,
                enableRetinaScaling: true,
                renderOnAddRemove: true
            });

            // Set Professional Selection Styles
            const primaryColor = getComputedStyle(document.documentElement).getPropertyValue('--primary').trim() || '#3B82F6';

            fabric.Object.prototype.set({
                borderColor: primaryColor,
                cornerColor: 'white',
                cornerStrokeColor: primaryColor,
                transparentCorners: false,
                cornerSize: 7,
                cornerStyle: 'circle',
                borderDashArray: [4, 3],
                padding: 1,
                borderScaleFactor: 1.5
            });

            createArtboard(currentWidth, currentHeight);
            setupEvents();
            saveHistory();
        }

        function createArtboard(widthMm, heightMm) {
            currentWidth = widthMm;
            currentHeight = heightMm;

            if (artboard) canvas.remove(artboard);

            const w = mmToPx(widthMm);
            const h = mmToPx(heightMm);
            const centerX = getWorkspaceCenterX();

            artboard = new fabric.Rect({
                left: centerX - w / 2,
                top: (workspaceHeight - h) / 2,
                width: w,
                height: h,
                fill: 'white',
                selectable: false,
                evented: false,
                shadow: new fabric.Shadow({ color: 'rgba(0,0,0,0.1)', blur: 20, offsetX: 0, offsetY: 4 }),
                excludeFromExport: true,
                absolutePositioned: true,
                isArtboard: true
            });

            canvas.add(artboard);
            artboard.sendToBack();

            // Update UI Labels
            document.getElementById('canvas-size-label').innerText = `Size : ${widthMm} × ${heightMm} mm`;
            document.getElementById('custom-width-input').value = widthMm;
            document.getElementById('custom-height-input').value = heightMm;

            fitToScreen();
            updateWorkspaceUIPositions();
        }

        // --- EVENTS ---
        function setupEvents() {
            // Visual Mask Overlay (Dimmed workspace outside artboard)
            canvas._renderOverlay = function (ctx) {
                if (!artboard) return;
                const vpt = this.viewportTransform;
                const zoom = this.getZoom();

                const l = artboard.left * zoom + vpt[4];
                const t = artboard.top * zoom + vpt[5];
                const w = artboard.width * zoom;
                const h = artboard.height * zoom;

                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                ctx.beginPath();
                ctx.rect(0, 0, this.width, this.height);
                ctx.moveTo(l, t);
                ctx.lineTo(l, t + h);
                ctx.lineTo(l + w, t + h);
                ctx.lineTo(l + w, t);
                ctx.closePath();
                ctx.fill('evenodd');
                ctx.restore();
            };

            canvas.on('mouse:wheel', function (opt) {
                const delta = opt.e.deltaY;
                let zoom = canvas.getZoom();
                zoom *= 0.999 ** delta;
                if (zoom > 20) zoom = 20;
                if (zoom < 0.05) zoom = 0.05;
                canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);
                opt.e.preventDefault();
                opt.e.stopPropagation();
                updateZoomDisplay();
                updateCanvasSizeLabel();
            });

            canvas.on('mouse:down', function (opt) {
                // Handle eyedropper sampling
                if (eyedropperActive) {
                    sampleColorFromCanvas(opt);
                    return;
                }

                if (isSpacePressed) {
                    this.isDragging = true;
                    this.lastPosX = opt.e.clientX;
                    this.lastPosY = opt.e.clientY;
                    canvas.selection = false;
                    document.body.className = 'cursor-grabbing';
                    canvas.defaultCursor = CURSOR_GRABBING;
                }
            });

            canvas.on('mouse:move', function (opt) {
                // Update eyedropper magnifier if active
                if (eyedropperActive) {
                    updateEyedropperMagnifier(opt);
                    return;
                }

                if (this.isDragging) {
                    const e = opt.e;
                    const vpt = this.viewportTransform;
                    vpt[4] += e.clientX - this.lastPosX;
                    vpt[5] += e.clientY - this.lastPosY;
                    this.requestRenderAll();
                    this.lastPosX = e.clientX;
                    this.lastPosY = e.clientY;
                    updateCanvasSizeLabel();
                }
            });

            canvas.on('mouse:up', function () {
                this.setViewportTransform(this.viewportTransform);
                this.isDragging = false;
                canvas.selection = true;
                if (isSpacePressed) {
                    document.body.className = 'cursor-grab';
                    canvas.defaultCursor = CURSOR_GRAB;
                } else {
                    document.body.className = 'cursor-default';
                    canvas.defaultCursor = 'default';
                }

                canvas.getObjects().forEach(obj => {
                    if (obj.excludeFromExport) obj.selectable = false;
                });
            });

            const sanitizeSelection = (e) => {
                const selected = (e && e.selected) || [];
                const filtered = selected.filter(o => !o.isArtboard && !o.excludeFromExport);
                if (selected.length && filtered.length !== selected.length) {
                    if (filtered.length === 0) {
                        canvas.discardActiveObject();
                    } else if (filtered.length === 1) {
                        canvas.setActiveObject(filtered[0]);
                    } else {
                        const sel = new fabric.ActiveSelection(filtered, { canvas });
                        canvas.setActiveObject(sel);
                    }
                }
            };

            canvas.on('selection:created', (e) => {
                sanitizeSelection(e);
                updateFloatingToolbar();
                requestAnimationFrame(updateColorPickers);
                updateImageInfoLabel();
                renderLayerList();
            });
            canvas.on('selection:updated', (e) => {
                sanitizeSelection(e);
                updateFloatingToolbar();
                requestAnimationFrame(updateColorPickers);
                updateImageInfoLabel();
                renderLayerList();
            });
            canvas.on('selection:cleared', () => {
                updateImageInfoLabel();
                document.getElementById('prop-text').style.display = 'none';
                document.getElementById('prop-corner').style.display = 'none';
                document.getElementById('prop-fill').style.display = 'none';
                document.getElementById('prop-stroke').style.display = 'none';
                hideFloatingToolbar();
                renderLayerList();
            });

            canvas.on('object:moving', (opt) => {
                updateFloatingToolbar(opt);
                updateObjectClipping(opt.target);
                if (opt.target?.isFrameContent && opt.target.group?.isFrameGroup) {
                    constrainFrameContent(opt.target.group, opt.target);
                }
            });
            canvas.on('object:scaling', (opt) => {
                updateFloatingToolbar(opt);
                updateObjectClipping(opt.target);
                updateImageInfoLabel();
                if (opt.target?.isFrameContent && opt.target.group?.isFrameGroup) {
                    constrainFrameContent(opt.target.group, opt.target);
                }
            });
            canvas.on('object:rotating', (opt) => { updateFloatingToolbar(opt); updateObjectClipping(opt.target); });

            canvas.on('object:added', (opt) => { !isUndoing && saveHistory(); checkCanvasBoundaries(); updateObjectClipping(opt.target); renderLayerList(); });
            canvas.on('object:modified', (opt) => { !isUndoing && saveHistory(); checkCanvasBoundaries(); updateObjectClipping(opt.target); });
            canvas.on('object:removed', () => { !isUndoing && saveHistory(); checkCanvasBoundaries(); });
            canvas.on('text:changed', (opt) => {
                const target = opt.target;
                if (!target || !target.group || !target.group.isTextStrokeGroup) return;
                syncTextStrokeGroup(target.group);
            });

            // Update UI alignment after every render for pixel-perfect centering
            canvas.on('after:render', () => {
                updateCanvasSizeLabel();
            });

            window.addEventListener('keydown', handleKeydown);
            window.addEventListener('keyup', handleKeyup);
        }

        function handleKeydown(e) {
            if (e.code === 'Space' && !e.target.matches('input, textarea, select')) {
                if (!isSpacePressed) {
                    isSpacePressed = true;
                    document.body.className = 'cursor-grab';
                    canvas.defaultCursor = CURSOR_GRAB;
                }
                e.preventDefault();
            }
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (!e.target.matches('input, textarea, select')) deleteSelected();
            }
            if (e.ctrlKey) {
                if (e.key === 'a' || e.key === 'A') {
                    if (!e.target.matches('input, textarea, select')) {
                        e.preventDefault();
                        selectAllVisible();
                    }
                }
                if (e.key === 'z') { e.preventDefault(); undo(); }
                if (e.key === 'y' || (e.shiftKey && e.key === 'Z')) { e.preventDefault(); redo(); }
                if (e.key === 'd') { e.preventDefault(); duplicateSelected(); }
                if (e.key === '0') { e.preventDefault(); fitToScreen(); }
            }
        }

        function handleKeyup(e) {
            if (e.code === 'Space') {
                isSpacePressed = false;
                document.body.className = 'cursor-default';
                canvas.defaultCursor = 'default';
            }
        }

        // --- ACTIONS ---
        function setCanvasSize(w, h, name) {
            scaleAllObjects(w, h);
            createArtboard(w, h);
            canvas.getObjects().forEach(o => updateObjectClipping(o));
            document.querySelectorAll('.preset-card').forEach(c => {
                c.classList.toggle('active', c.innerText.includes(name));
            });
        }

        function applyCustomSize() {
            const w = parseInt(document.getElementById('custom-width-input').value);
            const h = parseInt(document.getElementById('custom-height-input').value);
            if (w > 0 && h > 0) {
                scaleAllObjects(w, h);
                createArtboard(w, h);
                canvas.getObjects().forEach(o => updateObjectClipping(o));
                document.querySelectorAll('.preset-card').forEach(c => c.classList.remove('active'));
                checkCanvasBoundaries();
            }
        }

        function scaleAllObjects(newWidthMm, newHeightMm) {
            if (!artboard) return;
            const oldW = artboard.width;
            const oldH = artboard.height;
            const newW = mmToPx(newWidthMm);
            const newH = mmToPx(newHeightMm);

            const ratioX = newW / oldW;
            const ratioY = newH / oldH;

            // New artboard position (same logic as createArtboard)
            const nextArtLeft = getWorkspaceCenterX() - newW / 2;
            const nextArtTop = (workspaceHeight - newH) / 2;

            const objects = canvas.getObjects().filter(o => !o.excludeFromExport);

            objects.forEach(obj => {
                // Distance from old artboard top-left
                const dx = obj.left - artboard.left;
                const dy = obj.top - artboard.top;

                obj.set({
                    left: nextArtLeft + dx * ratioX,
                    top: nextArtTop + dy * ratioY
                });
                obj.setCoords();
            });
            canvas.renderAll();
        }

        function selectAllVisible() {
            const activeObj = canvas.getActiveObject();
            if (activeObj && activeObj.isEditing) return; // Don't select all if editing text

            const objects = canvas.getObjects().filter(obj => {
                return !obj.excludeFromExport && obj.visible && !obj.lockMovementX;
            });

            if (objects.length > 0) {
                canvas.discardActiveObject();
                const sel = new fabric.ActiveSelection(objects, { canvas: canvas });
                canvas.setActiveObject(sel);
                canvas.requestRenderAll();
            }
        }

        function getObjectBounds(obj) {
            const rect = obj.getBoundingRect(true, true);
            return {
                left: rect.left,
                top: rect.top,
                right: rect.left + rect.width,
                bottom: rect.top + rect.height,
                width: rect.width,
                height: rect.height
            };
        }

        function rectsIntersect(a, b) {
            return !(a.right < b.left || a.left > b.right || a.bottom < b.top || a.top > b.bottom);
        }

        function checkCanvasBoundaries() {
            if (!artboard) return;
            const objects = canvas.getObjects().filter(o => !o.excludeFromExport && o.visible);
            const artRect = getObjectBounds(artboard);

            let hasFullyOutside = false;
            objects.forEach(obj => {
                const objRect = getEffectiveBounds(obj);
                const isFullyOutside = !rectsIntersect(objRect, artRect);
                if (isFullyOutside) hasFullyOutside = true;
            });

            const warning = document.getElementById('boundary-warning');
            if (warning) {
                const warningSpan = warning.querySelector('span');
                if (warningSpan) warningSpan.innerText = "인쇄 영역을 벗어난 개체가 있습니다.";
                warning.classList.toggle('show', hasFullyOutside);
            }
            return hasFullyOutside;
        }

        function updateObjectClipping(obj) {
            if (!artboard || !obj || obj.isArtboard || obj.excludeFromExport) return;
            const artRect = getObjectBounds(artboard);

            const process = (o) => {
                if (o.type === 'activeSelection') {
                    o.getObjects().forEach(process);
                    return;
                }

                const objRect = getEffectiveBounds(o);
                const isPartiallyInside = rectsIntersect(objRect, artRect);

                if (isPartiallyInside) {
                    if (o._wasOutOfBounds) {
                        o.set({
                            opacity: o._userOpacity || 1,
                            strokeDashArray: null
                        });
                        delete o._wasOutOfBounds;
                    }

                    // CRITICAL FIX: Do not overwrite user-applied masks
                    if (o.clipPath && !o.clipPath.isArtboardClip) return;

                    if (!o.clipPath || !o.clipPath.isArtboardClip) {
                        o.clipPath = new fabric.Rect({
                            left: artboard.left,
                            top: artboard.top,
                            width: artboard.width,
                            height: artboard.height,
                            absolutePositioned: true,
                            isArtboardClip: true
                        });
                    } else {
                        o.clipPath.set({
                            left: artboard.left,
                            top: artboard.top,
                            width: artboard.width,
                            height: artboard.height
                        });
                    }
                } else {
                    // Fully Outside
                    if (o.clipPath && o.clipPath.isArtboardClip) {
                        o.clipPath = null;
                    }
                    if (!o._wasOutOfBounds) {
                        o._userOpacity = o.opacity;
                        o.set({
                            opacity: (o.opacity || 1) * 0.4,
                            strokeDashArray: [5, 5]
                        });
                        o._wasOutOfBounds = true;
                    }
                }
            };

            process(obj);
            canvas.requestRenderAll();
        }

        function handleExportRequest() {
            if (checkCanvasBoundaries()) {
                // Warning is already shown via checkCanvasBoundaries
            }
            exportToPDF();
        }

        function updateZoomDisplay() {
            const zoom = Math.round(canvas.getZoom() * 100);
            const zoomValue = zoom + '%';

            // Update both zoom inputs (top and bottom)
            const inputTop = document.getElementById('zoom-input');
            const inputBottom = document.getElementById('zoom-input-bottom');
            if (inputTop) inputTop.value = zoomValue;
            if (inputBottom) inputBottom.value = zoomValue;
        }

        function handleZoomInput(val) {
            let num = parseInt(val.replace('%', ''));
            if (isNaN(num)) return updateZoomDisplay();

            // Constrain zoom
            num = Math.max(5, Math.min(2000, num));
            const zoom = num / 100;

            // Zoom relative to the center of the current canvas view
            const center = {
                x: canvas.getWidth() / 2,
                y: canvas.getHeight() / 2
            };

            canvas.zoomToPoint(center, zoom);
            updateZoomDisplay();
        }

        function selectOutsideObjects() {
            if (!artboard) return;
            const artRect = artboard.getBoundingRect(true);
            const outside = canvas.getObjects().filter(obj => {
                if (obj.excludeFromExport) return false;
                const objRect = obj.getBoundingRect(true);
                return (
                    objRect.left < artRect.left - 0.1 ||
                    objRect.top < artRect.top - 0.1 ||
                    objRect.left + objRect.width > artRect.left + artRect.width + 0.1 ||
                    objRect.top + objRect.height > artRect.top + artRect.height + 0.1
                );
            });

            if (outside.length > 0) {
                canvas.discardActiveObject();
                if (outside.length === 1) {
                    canvas.setActiveObject(outside[0]);
                } else {
                    const sel = new fabric.ActiveSelection(outside, { canvas: canvas });
                    canvas.setActiveObject(sel);
                }
                canvas.requestRenderAll();
            }
        }
        function fitToScreen() {
            if (!artboard) return;
            const padding = 80;
            const w = artboard.width * artboard.scaleX;
            const h = artboard.height * artboard.scaleY;
            const scale = Math.min(
                (workspaceWidth - padding) / w,
                (workspaceHeight - padding) / h
            );
            const finalScale = Math.min(scale, 2); // Cap zoom to ~200% for small presets
            canvas.setZoom(finalScale);
            const vpt = canvas.viewportTransform;
            const workspaceCenter = getWorkspaceCenterX();
            vpt[4] = workspaceCenter - (artboard.left + w / 2) * finalScale;
            vpt[5] = workspaceHeight / 2 - (artboard.top + h / 2) * finalScale;
            canvas.requestRenderAll();
            updateZoomDisplay();
            updateCanvasSizeLabel();
        }

        function updateCanvasSizeLabel() {
            // Fixed positions via CSS - no dynamic updates needed
        }

        function updateImageInfoLabel() {
            const label = document.getElementById('image-info-label');
            if (!label) return;

            const obj = canvas.getActiveObject();
            if (!obj || obj.type !== 'image' || obj.excludeFromExport) {
                label.innerText = '';
                return;
            }

            // Calculate effective PPI
            const printedWidthMm = (obj.width * obj.scaleX) / MM_TO_PX_SCREEN;
            const printedWidthInches = printedWidthMm / 25.4;
            const ppi = Math.round(obj.width / printedWidthInches);

            label.innerText = ` - Image : ${ppi} ppi`;
        }

        // Collapsible sections (Figma style)
        function toggleSection(sectionId) {
            const content = document.getElementById(`content-${sectionId}`);
            const icon = document.getElementById(`icon-${sectionId}`);
            if (!content || !icon) return;

            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                icon.classList.remove('collapsed');
                content.style.maxHeight = content.scrollHeight + 'px';
            } else {
                content.classList.add('collapsed');
                icon.classList.add('collapsed');
                content.style.maxHeight = '0';
            }

            // Auto-expand layers section and re-render
            if (sectionId === 'layers' && !content.classList.contains('collapsed')) {
                renderLayerList();
            }
        }

        // Initialize sections (set initial max-height)
        window.addEventListener('load', () => {
            ['presets', 'custom-size', 'layers'].forEach(id => {
                const content = document.getElementById(`content-${id}`);
                if (content) {
                    content.style.maxHeight = content.scrollHeight + 'px';
                }
            });
        });

        // Tool dropdown management
        let currentDropdown = null;

        function toggleToolDropdown(toolType) {
            const dropdown = document.getElementById(`${toolType}-dropdown`);

            // Close other dropdowns
            if (currentDropdown && currentDropdown !== dropdown) {
                currentDropdown.classList.remove('show');
            }

            // Toggle current dropdown
            dropdown.classList.toggle('show');
            currentDropdown = dropdown.classList.contains('show') ? dropdown : null;
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.figma-tool-btn') && !e.target.closest('.tool-dropdown')) {
                document.querySelectorAll('.tool-dropdown').forEach(d => d.classList.remove('show'));
                currentDropdown = null;
            }
        });

        // Line tool selection
        function selectLineTool(type) {
            addShape(type);
            document.getElementById('line-dropdown').classList.remove('show');
            currentDropdown = null;

            // Update icon
            const iconContainer = document.getElementById('line-tool-icon');
            if (type === 'line') {
                iconContainer.innerHTML = '<line x1="5" y1="12" x2="19" y2="12" />';
            } else if (type === 'arrow') {
                iconContainer.innerHTML = '<path d="M5 12h14M13 5l7 7-7 7" />';
            }
        }

        // Shape tool selection
        function selectShapeTool(type) {
            addShape(type);
            document.getElementById('shape-dropdown').classList.remove('show');
            currentDropdown = null;

            // Update icon
            const iconContainer = document.getElementById('shape-tool-icon');
            const icons = {
                'rect': '<rect x="3" y="3" width="18" height="18" rx="2" />',
                'circle': '<circle cx="12" cy="12" r="10" />',
                'triangle': '<path d="M12 3l9 18H3L12 3z" />',
                'star': '<path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" />',
                'heart': '<path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z" />'
            };
            iconContainer.innerHTML = icons[type] || icons['rect'];
        }

        // Left toolbar tool selection
        let currentTool = 'select';

        function setPanelTitle(text) {
            const titleEl = document.getElementById('layer-panel-title');
            if (titleEl) titleEl.innerText = text;
        }

        function exitArtboardMode() {
            const presets = document.getElementById('print-presets-section');
            const layerList = document.getElementById('regular-layer-list');
            const closeBtn = document.getElementById('panel-close-btn');
            currentTool = 'select';
            document.querySelectorAll('.left-toolbar-btn').forEach(btn => btn.classList.remove('active'));
            if (presets) presets.style.display = 'none';
            if (layerList) layerList.style.display = 'block';
            if (closeBtn) closeBtn.style.display = 'none';
            setPanelTitle('레이어');
            canvas.defaultCursor = 'default';
            canvas.selection = true;
            canvas.discardActiveObject();
            canvas.requestRenderAll();
        }

        function selectTool(tool) {
            if (tool === 'artboard' && currentTool === 'artboard') {
                exitArtboardMode();
                return;
            }

            // Remove active class from all toolbar buttons
            document.querySelectorAll('.left-toolbar-btn').forEach(btn => {
                btn.classList.remove('active');
            });

            // Add active class to selected tool
            const toolBtn = document.getElementById(`${tool}-tool-btn`);
            if (toolBtn) {
                toolBtn.classList.add('active');
            }

            currentTool = tool;

            // Handle tool-specific actions
            if (tool === 'select') {
                canvas.defaultCursor = 'default';
                canvas.selection = true;
                // Show regular layer list
                document.getElementById('print-presets-section').style.display = 'none';
                document.getElementById('regular-layer-list').style.display = 'block';
                const closeBtn = document.getElementById('panel-close-btn');
                if (closeBtn) closeBtn.style.display = 'none';
                setPanelTitle('레이어');
            } else if (tool === 'artboard') {
                // Select artboard and show presets
                if (artboard) {
                    canvas.setActiveObject(artboard);
                    canvas.renderAll();
                }
                document.getElementById('print-presets-section').style.display = 'block';
                document.getElementById('regular-layer-list').style.display = 'none';
                const closeBtn = document.getElementById('panel-close-btn');
                if (closeBtn) closeBtn.style.display = 'inline-flex';
                setPanelTitle('프리셋');
            } else if (tool === 'text') {
                addText();
                // Reset to select tool after adding
                setTimeout(() => selectTool('select'), 100);
            } else if (tool === 'rect') {
                addShape('rect');
                setTimeout(() => selectTool('select'), 100);
            } else if (tool === 'circle') {
                addShape('circle');
                setTimeout(() => selectTool('select'), 100);
            } else if (tool === 'triangle') {
                addShape('triangle');
                setTimeout(() => selectTool('select'), 100);
            } else if (tool === 'star') {
                addShape('star');
                setTimeout(() => selectTool('select'), 100);
            } else if (tool === 'line') {
                addShape('line');
                setTimeout(() => selectTool('select'), 100);
            } else if (tool === 'arrow') {
                addShape('arrow');
                setTimeout(() => selectTool('select'), 100);
            } else if (tool === 'image') {
                document.getElementById('img-upload').click();
                setTimeout(() => selectTool('select'), 100);
            }
        }

        // Apply print size preset
        function applyPreset(width, height, name) {
            // Remove active class from all presets
            document.querySelectorAll('.preset-item').forEach(item => {
                item.classList.remove('active');
            });

            // Add active class to clicked preset
            event.target.closest('.preset-item').classList.add('active');

            // Apply the size
            currentWidth = width;
            currentHeight = height;

            // Update artboard
            if (artboard) {
                const newWidth = mmToPx(width);
                const newHeight = mmToPx(height);
                const centerX = getWorkspaceCenterX();

                artboard.set({
                    width: newWidth,
                    height: newHeight,
                    scaleX: 1,
                    scaleY: 1,
                    left: centerX - newWidth / 2,
                    top: (workspaceHeight - newHeight) / 2
                });

                artboard.setCoords();
                canvas.renderAll();
            }

            // Update canvas label
            document.getElementById('canvas-size-label').innerText = `Size : ${width} × ${height} mm`;
            const customWidthInput = document.getElementById('custom-width-input');
            const customHeightInput = document.getElementById('custom-height-input');
            if (customWidthInput) customWidthInput.value = width;
            if (customHeightInput) customHeightInput.value = height;

            // Fit to screen
            fitToScreen();
            updateWorkspaceUIPositions();

            saveHistory();
        }

        function addShape(type) {
            const center = artboard.getCenterPoint();
            const minDim = Math.min(artboard.width, artboard.height);
            const size = minDim * 0.2; // 20% of artboard's smallest dimension

            let obj;
            const props = {
                left: center.x,
                top: center.y,
                fill: 'transparent',
                stroke: '#1F2937',
                strokeWidth: 1,
                strokeUniform: true,  // Uniform stroke scaling
                paintFirst: 'fill',   // Paint fill before stroke
                originX: 'center',
                originY: 'center',
                opacity: 1
            };

            if (type === 'rect') {
                obj = new fabric.Rect({ ...props, width: size, height: size });
            } else if (type === 'circle') {
                obj = new fabric.Circle({ ...props, radius: size / 2 });
            } else if (type === 'triangle') {
                obj = new fabric.Triangle({ ...props, width: size, height: size });
            } else if (type === 'star') {
                // Star points relative to size 100, then scaled
                obj = new fabric.Polygon([
                    { x: 0, y: -50 }, { x: 13, y: -15 }, { x: 50, y: -15 }, { x: 20, y: 10 },
                    { x: 31, y: 48 }, { x: 0, y: 25 }, { x: -31, y: 48 }, { x: -20, y: 10 },
                    { x: -50, y: -15 }, { x: -13, y: -15 }
                ], props);
                obj.scaleToWidth(size);
            } else if (type === 'heart') {
                obj = new fabric.Path('M 12 21.35 l -1.45 -1.32 C 5.4 15.36 2 12.28 2 8.5 C 2 5.42 4.42 3 7.5 3 c 1.74 0 3.41 0.81 4.5 2.09 C 13.09 3.81 14.76 3 16.5 3 C 19.58 3 22 5.42 22 8.5 c 0 3.78 -3.4 6.86 -8.55 11.54 L 12 21.35 z', props);
                obj.scaleToWidth(size);
            } else if (type === 'line') {
                obj = new fabric.Line([center.x - size / 2, center.y, center.x + size / 2, center.y], {
                    ...props,
                    left: center.x,
                    top: center.y,
                    strokeWidth: 1 * MM_TO_PX_SCREEN, // 1mm default
                    fill: 'transparent',
                    stroke: '#000000'
                });
            } else if (type === 'arrow') {
                // Line-based arrow
                const shaftLen = size;
                const headLen = size * 0.2;
                const headWidth = size * 0.15;
                const pathData = `M 0 0 L ${shaftLen} 0 M ${shaftLen - headLen} ${-headWidth} L ${shaftLen} 0 L ${shaftLen - headLen} ${headWidth}`;
                obj = new fabric.Path(pathData, {
                    ...props,
                    fill: 'transparent',
                    stroke: '#000000',
                    strokeWidth: 1 * MM_TO_PX_SCREEN, // 1mm default
                    strokeLineCap: 'round',
                    strokeLineJoin: 'round'
                });
            }


            ensureObjectId(obj);
            canvas.add(obj);
            canvas.setActiveObject(obj);
            canvas.renderAll();
        }

        function addText() {
            const center = artboard.getCenterPoint();
            const minDim = Math.min(artboard.width, artboard.height);
            const dynamicFontSize = Math.max(12, minDim * 0.05); // 5% of min dimension, min 12px

            const text = new fabric.IText('더블 클릭하여 편집', {
                left: center.x,
                top: center.y,
                fontFamily: 'Pretendard',
                fontSize: dynamicFontSize,
                fill: '#1F2937',
                stroke: null,
                strokeWidth: 0,
                originX: 'center',
                originY: 'center',
                opacity: 1
            });
            ensureObjectId(text);
            canvas.add(text);
            canvas.setActiveObject(text);
            canvas.renderAll();
        }

        function placeAtCenterAndSelect(obj, targetWidthFraction = 0.4) {
            const center = artboard.getCenterPoint();
            const minDim = Math.min(artboard.width, artboard.height);
            const targetWidth = minDim * targetWidthFraction;
            obj.set({ left: center.x, top: center.y, originX: 'center', originY: 'center', opacity: 1 });
            if (obj.scaleToWidth) obj.scaleToWidth(targetWidth);
            ensureObjectId(obj);
            canvas.add(obj);
            canvas.setActiveObject(obj);
            canvas.renderAll();
        }

        async function handleImageUpload(input) {
            const file = input.files[0];
            if (!file) return;

            const nameLower = file.name.toLowerCase();
            const type = file.type;

            try {
                if (nameLower.endsWith('.ai')) {
                    alert('AI 파일은 현재 직접 불러올 수 없습니다. PDF/SVG/PNG로 변환 후 업로드해주세요.');
                    return;
                }

                if (nameLower.endsWith('.pdf') || type === 'application/pdf') {
                    await importPdf(file);
                    return;
                }

                if (nameLower.endsWith('.svg') || type === 'image/svg+xml') {
                    await importSvg(file);
                    return;
                }

                // Fallback to raster image
                const dataUrl = await fileToDataURL(file);
                fabric.Image.fromURL(dataUrl, (img) => {
                    placeAtCenterAndSelect(img);
                });
            } catch (err) {
                console.error('파일 불러오기 실패:', err);
                alert('파일을 불러오는 중 문제가 발생했습니다: ' + err.message);
            } finally {
                input.value = '';
            }
        }

        function fileToDataURL(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        function fileToText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsText(file);
            });
        }

        async function importSvg(file) {
            const svgText = await fileToText(file);
            return new Promise((resolve, reject) => {
                fabric.loadSVGFromString(svgText, (objects, options) => {
                    if (!objects || !objects.length) {
                        reject(new Error('SVG를 파싱할 수 없습니다.'));
                        return;
                    }
                    const svgObj = fabric.util.groupSVGElements(objects, options);
                    placeAtCenterAndSelect(svgObj, 0.6); // 조금 더 크게
                    resolve();
                });
            });
        }

        async function importPdf(file) {
            if (!window['pdfjsLib']) throw new Error('PDF.js가 로드되지 않았습니다.');
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            const page = await pdf.getPage(1);
            const viewport = page.getViewport({ scale: 2 });
            const canvasEl = document.createElement('canvas');
            canvasEl.width = viewport.width;
            canvasEl.height = viewport.height;
            const ctx = canvasEl.getContext('2d');
            await page.render({ canvasContext: ctx, viewport }).promise;
            const dataUrl = canvasEl.toDataURL('image/png');
            return new Promise((resolve) => {
                fabric.Image.fromURL(dataUrl, (img) => {
                    placeAtCenterAndSelect(img, 0.7);
                    resolve();
                });
            });
        }

        function isTextObject(obj) {
            return obj && (obj.type === 'i-text' || obj.type === 'text' || obj.type === 'textbox');
        }

        function getTextStrokeGroupParts(group) {
            if (!group || !group.isTextStrokeGroup) return null;
            const stroke = group._objects.find(child => child.isTextStrokeOutline) || group._objects[0];
            const fill = group._objects.find(child => child.isTextFill) || group._objects[1];
            return { stroke, fill };
        }

        function buildTextClone(source, overrides = {}) {
            const commonProps = {
                left: source.left,
                top: source.top,
                originX: source.originX,
                originY: source.originY,
                angle: source.angle,
                scaleX: source.scaleX,
                scaleY: source.scaleY,
                skewX: source.skewX,
                skewY: source.skewY,
                flipX: source.flipX,
                flipY: source.flipY,
                fontFamily: source.fontFamily,
                fontSize: source.fontSize,
                fontWeight: source.fontWeight,
                fontStyle: source.fontStyle,
                textAlign: source.textAlign,
                lineHeight: source.lineHeight,
                charSpacing: source.charSpacing,
                underline: source.underline,
                linethrough: source.linethrough,
                overline: source.overline,
                direction: source.direction,
                textBaseline: 'alphabetic',  // Fix: ensure valid textBaseline value
                styles: JSON.parse(JSON.stringify(source.styles || {}))
            };

            if (source.type === 'textbox') {
                return new fabric.Textbox(source.text, { ...commonProps, width: source.width, ...overrides });
            }
            if (source.type === 'text') {
                return new fabric.Text(source.text, { ...commonProps, ...overrides });
            }
            return new fabric.IText(source.text, { ...commonProps, ...overrides });
        }

        function createTextStrokeGroup(textObj, strokeWidth, strokeColor, centerPoint) {
            try {
                console.log('[createTextStrokeGroup] Starting with:', {
                    text: textObj.text,
                    strokeWidth,
                    strokeColor,
                    textType: textObj.type,
                    centerPoint
                });

                // Save all original properties before modification
                const originalProps = {
                    left: textObj.left,
                    top: textObj.top,
                    angle: textObj.angle,
                    scaleX: textObj.scaleX,
                    scaleY: textObj.scaleY,
                    originX: textObj.originX,
                    originY: textObj.originY
                };
                const savedCenter = centerPoint || textObj.getCenterPoint();
                console.log('[createTextStrokeGroup] Saved center:', savedCenter);

                // Create stroke clone with same position as text
                const stroke = buildTextClone(textObj, {
                    fill: 'transparent',
                    stroke: strokeColor,
                    strokeWidth: strokeWidth,  // Use actual width, not doubled
                    strokeUniform: true,
                    strokeLineCap: 'round',
                    strokeLineJoin: 'round',
                    selectable: false,
                    evented: false
                });
                stroke.isTextStrokeOutline = true;
                console.log('[createTextStrokeGroup] Stroke clone created:', stroke.type);

                // Remove stroke from fill text
                textObj.set({
                    strokeWidth: 0,
                    stroke: null
                });
                textObj.isTextFill = true;

                // Create group without setting position (let Fabric calculate it)
                const group = new fabric.Group([stroke, textObj], {
                    subTargetCheck: true,
                    selectable: true,
                    evented: true,
                    objectCaching: false
                });
                console.log('[createTextStrokeGroup] Group created:', group.type, group._objects?.length);

                // Now position the group at the saved center point
                group.set({
                    left: savedCenter.x,
                    top: savedCenter.y,
                    angle: originalProps.angle,
                    scaleX: originalProps.scaleX,
                    scaleY: originalProps.scaleY,
                    originX: 'center',
                    originY: 'center'
                });

                group.isTextStrokeGroup = true;
                group.textStrokeWidth = strokeWidth;
                group.textStrokeColor = strokeColor;
                group.setCoords();

                // Mark as dirty to ensure proper rendering
                stroke.dirty = true;
                textObj.dirty = true;
                group.dirty = true;

                const bounds = group.getBoundingRect();
                console.log('[createTextStrokeGroup] Success! Group bounds:', bounds);

                // Verify the group has valid dimensions
                if (!bounds || bounds.width === 0 || bounds.height === 0) {
                    console.error('[createTextStrokeGroup] Invalid group bounds!', bounds);
                    throw new Error('Group has invalid bounds');
                }

                return group;
            } catch (error) {
                console.error('[createTextStrokeGroup] Error:', error);
                console.error('[createTextStrokeGroup] Stack:', error.stack);
                // Restore textObj to its original state
                textObj.set({
                    strokeWidth: 0,
                    stroke: null
                });
                return textObj;
            }
        }

        function syncTextStrokeGroup(group) {
            const parts = getTextStrokeGroupParts(group);
            if (!parts) return;
            const { stroke, fill } = parts;
            if (!stroke || !fill) return;

            stroke.set({
                text: fill.text,
                fontFamily: fill.fontFamily,
                fontSize: fill.fontSize,
                fontWeight: fill.fontWeight,
                fontStyle: fill.fontStyle,
                textAlign: fill.textAlign,
                lineHeight: fill.lineHeight,
                charSpacing: fill.charSpacing,
                underline: fill.underline,
                linethrough: fill.linethrough,
                overline: fill.overline,
                direction: fill.direction,
                styles: JSON.parse(JSON.stringify(fill.styles || {}))
            });
            // Mark objects as dirty to force re-render
            stroke.dirty = true;
            fill.dirty = true;
            group.dirty = true;
            group._calcBounds();
            group._updateObjectsCoords();
            group.setCoords();
        }

        // --- PROPERTIES ---
        function updateColorPickers() {
            const obj = canvas.getActiveObject();
            if (!obj) return;

            // Show fill and stroke panels when object is selected
            const isLine = obj.type === 'line';
            const isGroupLike = obj.type === 'group' || obj.isMaskGroup || obj.isFrameGroup;
            const isImageLike = obj.type === 'image' || obj.isFrameContent || obj.isMaskGroup || obj.isFrameGroup;

            const fillPanel = document.getElementById('prop-fill');
            const strokePanel = document.getElementById('prop-stroke');

            const allowFillStroke = !isGroupLike && !isImageLike;
            if (fillPanel) fillPanel.style.display = allowFillStroke && !isLine ? 'block' : 'none';
            if (strokePanel) strokePanel.style.display = allowFillStroke ? 'block' : 'none';

            const textTarget = obj.isTextStrokeGroup ? (getTextStrokeGroupParts(obj)?.fill || obj) : obj;
            if (isTextObject(textTarget)) {
                document.getElementById('prop-text').style.display = 'block';
                const fontFamily = textTarget.fontFamily || 'Pretendard';
                const chosenWeight = setFontWeightOptions(fontFamily, textTarget.fontWeight || '400');
                document.getElementById('font-family').value = fontFamily;
                document.getElementById('font-size').value = Math.round(textTarget.fontSize || 24);
                document.getElementById('font-weight').value = chosenWeight;
                document.getElementById('line-height').value = textTarget.lineHeight || 1.16;
                document.getElementById('char-spacing').value = textTarget.charSpacing || 0;
            } else {
                document.getElementById('prop-text').style.display = 'none';
            }

            // Opacity & Corner Sync
            const opVal = Math.round((obj.opacity || 1) * 100);
            const opIn = document.getElementById('global-opacity');
            if (opIn) {
                opIn.value = opVal;
                document.getElementById('global-opacity-val').innerText = opVal;
            }
            const cRow = document.getElementById('prop-corner');
            if (obj.type === 'rect' && !obj.excludeFromExport) {
                cRow.style.display = 'block';
                document.getElementById('corner-radius').value = obj.rx || 0;
                document.getElementById('corner-radius-val').innerText = Math.round(obj.rx || 0);
            } else {
                if (cRow) cRow.style.display = 'none';
            }

            if (obj.type === 'rect' || (obj.type === 'rect' && !obj.excludeFromExport)) {
                // Check if it's really a rectangle (not artboard)
                if (!obj.excludeFromExport) {
                    document.getElementById('prop-corner').style.display = 'block';
                    document.getElementById('corner-radius').value = obj.rx || 0;
                    document.getElementById('corner-radius-val').innerText = Math.round(obj.rx || 0);
                } else {
                    document.getElementById('prop-corner').style.display = 'none';
                }
            } else {
                document.getElementById('prop-corner').style.display = 'none';
            }

            // Fill sync
            const fill = textTarget.fill;
            const hasFill = fill && fill !== 'transparent';
            document.getElementById('fill-enabled').checked = hasFill;
            document.getElementById('fill-settings').style.display = hasFill ? 'block' : 'none';

            if (typeof fill === 'string') {
                const color = fill === 'transparent' ? '#3B82F6' : fill;
                document.getElementById('fill-swatch').style.background = color;
                document.getElementById('gradient-check').checked = false;
            }
            if (fill && fill.colorStops) {
                document.getElementById('gradient-check').checked = true;
                const s1 = fill.colorStops[0].color;
                const s2 = fill.colorStops[1].color;
                document.getElementById('grad-start-swatch').style.background = s1;
                document.getElementById('grad-end-swatch').style.background = s2;

                // Restore Type & Angle
                const type = fill.type || 'linear';
                document.getElementById('grad-type').value = type;
                if (obj.gradientAngle !== undefined) {
                    document.getElementById('grad-angle').value = obj.gradientAngle;
                    document.getElementById('grad-angle-val').innerText = obj.gradientAngle + '°';
                }

                toggleGradientMode();
            }

            // Stroke sync
            const strokeTarget = obj.isTextStrokeGroup ? (getTextStrokeGroupParts(obj)?.stroke || obj) : obj;
            const stroke = strokeTarget.stroke || '#000000';

            // Get stroke width - treat null, undefined, and 0 as no stroke
            let strokePx = 0;
            if (obj.isTextStrokeGroup) {
                // Old text stroke group format - will be converted to simple stroke
                strokePx = Math.round(obj.textStrokeWidth || 0);
            } else {
                const rawWidth = strokeTarget.strokeWidth;
                if (rawWidth !== null && rawWidth !== undefined && rawWidth > 0) {
                    // Use actual strokeWidth value directly
                    strokePx = Math.round(rawWidth);
                }
            }

            const hasStroke = strokePx > 0;
            document.getElementById('stroke-enabled').checked = hasStroke;
            document.getElementById('stroke-settings').style.display = hasStroke ? 'block' : 'none';

            document.getElementById('stroke-swatch').style.background = stroke;

            // Only update stroke width input if stroke is enabled
            if (hasStroke) {
                document.getElementById('stroke-width-input').value = strokePx;
                const dashLen = strokeTarget._dashLength || 0;
                const dashGap = strokeTarget._dashGap || 0;
                document.getElementById('dash-length').value = dashLen;
                document.getElementById('dash-gap').value = dashGap;
            } else {
                // Set default values when stroke is disabled
                document.getElementById('stroke-width-input').value = 1;
                document.getElementById('dash-length').value = 0;
                document.getElementById('dash-gap').value = 0;
            }

            // Opacity
            const opacity = Math.round((obj.opacity || 1) * 100);
            document.getElementById('global-opacity').value = opacity;
            document.getElementById('global-opacity-val').innerText = opacity;

            // Shadow
            const shadowAllowed = !(obj.isMaskGroup || obj.isFrameGroup);
            const hasShadow = shadowAllowed && obj.shadow !== null && obj.shadow !== undefined;
            const shadowEnabled = document.getElementById('shadow-enabled');
            const shadowSettings = document.getElementById('shadow-settings');
            if (shadowEnabled) shadowEnabled.disabled = !shadowAllowed;
            if (shadowSettings) shadowSettings.style.display = hasShadow ? 'block' : 'none';
            if (shadowEnabled) shadowEnabled.checked = hasShadow && shadowAllowed;
            if (hasShadow && shadowAllowed) {
                const shadow = obj.shadow;
                const shadowColor = shadow.color || 'rgba(0,0,0,0.5)';
                document.getElementById('shadow-color-swatch').style.background = shadowColor;
                document.getElementById('shadow-blur').value = shadow.blur || 10;
                document.getElementById('shadow-blur-val').innerText = shadow.blur || 10;
                document.getElementById('shadow-offset-x').value = shadow.offsetX || 5;
                document.getElementById('shadow-offset-x-val').innerText = shadow.offsetX || 5;
                document.getElementById('shadow-offset-y').value = shadow.offsetY || 5;
                document.getElementById('shadow-offset-y-val').innerText = shadow.offsetY || 5;
            } else if (shadowSettings) {
                shadowSettings.style.display = 'none';
            }

            const layerTab = document.getElementById('tab-layers');
            if (!layerTab || layerTab.style.display === 'block') {
                renderLayerList();
            }
        }

        function changeObjectOpacity(val) {
            const active = canvas.getActiveObject();
            if (!active) return;

            const opacity = parseFloat(val) / 100;
            if (active.type === 'activeSelection') {
                active.forEachObject(obj => {
                    if (!obj.lockMovementX) { // Ignore locked
                        obj.set('opacity', opacity);
                    }
                });
            } else {
                active.set('opacity', opacity);
            }

            document.getElementById('global-opacity-val').innerText = val;
            canvas.requestRenderAll();
            // We use standard object:modified and saveHistory handles it
        }

        function changeFillColor(val) {
            const obj = canvas.getActiveObject();
            if (!obj) return;

            const applyFill = (target) => {
                if (target.isTextStrokeGroup) {
                    const parts = getTextStrokeGroupParts(target);
                    if (parts && parts.fill) {
                        parts.fill.set('fill', val);
                        syncTextStrokeGroup(target);
                        setObjectColorData(parts.fill, 'fill', val);
                    }
                } else {
                    target.set('fill', val);
                    setObjectColorData(target, 'fill', val);
                }
            };

            if (obj.type === 'activeSelection') {
                obj.forEachObject(applyFill);
            } else {
                applyFill(obj);
            }
            document.getElementById('fill-swatch').style.background = val;
            canvas.renderAll();
            saveHistory();
        }

        function toggleTransparentFill() {
            const obj = canvas.getActiveObject();
            if (!obj) return;
            const isChecked = document.getElementById('transparent-check').checked;
            const color = isChecked ? 'transparent' : document.getElementById('fill-swatch').style.background;

            const applyFill = (target) => {
                if (target.isTextStrokeGroup) {
                    const parts = getTextStrokeGroupParts(target);
                    if (parts && parts.fill) {
                        parts.fill.set('fill', color);
                        syncTextStrokeGroup(target);
                        if (color !== 'transparent') setObjectColorData(parts.fill, 'fill', color);
                    }
                } else {
                    target.set('fill', color);
                    if (color !== 'transparent') setObjectColorData(target, 'fill', color);
                }
            };

            if (obj.type === 'activeSelection') {
                obj.forEachObject(applyFill);
            } else {
                applyFill(obj);
            }
            canvas.renderAll();
            saveHistory();
        }

        function toggleFillEnabled() {
            const obj = canvas.getActiveObject();
            if (!obj) return;

            const isEnabled = document.getElementById('fill-enabled').checked;
            const fillSettings = document.getElementById('fill-settings');

            const enableFill = (target, color) => {
                if (target.isTextStrokeGroup) {
                    const parts = getTextStrokeGroupParts(target);
                    if (parts && parts.fill) {
                        parts.fill.set('fill', color);
                        syncTextStrokeGroup(target);
                        setObjectColorData(parts.fill, 'fill', color);
                    }
                } else {
                    target.set('fill', color);
                    setObjectColorData(target, 'fill', color);
                }
            };

            const disableFill = (target) => {
                if (target.isTextStrokeGroup) {
                    const parts = getTextStrokeGroupParts(target);
                    if (parts && parts.fill) {
                        parts.fill.set('fill', 'transparent');
                        syncTextStrokeGroup(target);
                    }
                } else {
                    target.set('fill', 'transparent');
                }
            };

            if (isEnabled) {
                const color = document.getElementById('fill-swatch').style.background || '#3B82F6';
                if (obj.type === 'activeSelection') {
                    obj.forEachObject(o => enableFill(o, color));
                } else {
                    enableFill(obj, color);
                }
                fillSettings.style.display = 'block';
            } else {
                if (obj.type === 'activeSelection') {
                    obj.forEachObject(disableFill);
                } else {
                    disableFill(obj);
                }
                fillSettings.style.display = 'none';
            }
            canvas.renderAll();
            saveHistory();
        }

        function toggleStrokeEnabled() {
            const obj = canvas.getActiveObject();
            if (!obj) return;

            const isEnabled = document.getElementById('stroke-enabled').checked;
            const strokeSettings = document.getElementById('stroke-settings');

            const applyToggle = (target) => {
                if (isEnabled) {
                    const strokeWidth = parseInt(document.getElementById('stroke-width-input').value) || 1;
                    applyStrokeWidth(target, strokeWidth);
                } else {
                    applyStrokeWidth(target, 0);
                }
            };

            if (obj.type === 'activeSelection') {
                obj.forEachObject(applyToggle);
            } else {
                applyToggle(obj);
            }

            strokeSettings.style.display = isEnabled ? 'block' : 'none';
            canvas.renderAll();
            saveHistory();
        }

        function updateStrokeDash() {
            const obj = canvas.getActiveObject();
            if (!obj) return;

            const rawLen = parseInt(document.getElementById('dash-length').value) || 0;
            const rawGap = parseInt(document.getElementById('dash-gap').value) || 0;

            const applyDash = (target) => {
                const strokeTarget = target.isTextStrokeGroup ? getTextStrokeGroupParts(target)?.stroke : target;
                if (!strokeTarget) return;

                if (rawLen > 0 || rawGap > 0) {
                    const dashLen = Math.max(1, rawLen || rawGap || 4);
                    const dashGap = Math.max(1, rawGap || rawLen || 4);
                    strokeTarget.set('strokeDashArray', [dashLen, dashGap]);
                    strokeTarget._userStrokeDashed = true;
                    strokeTarget._dashLength = dashLen;
                    strokeTarget._dashGap = dashGap;
                } else {
                    strokeTarget.set('strokeDashArray', null);
                    strokeTarget._userStrokeDashed = false;
                }

                if (target.isTextStrokeGroup) {
                    strokeTarget.dirty = true;
                    target.dirty = true;
                }
            };

            if (obj.type === 'activeSelection') {
                obj.forEachObject(applyDash);
            } else {
                applyDash(obj);
            }

            canvas.renderAll();
            saveHistory();
        }

        function changeStrokeColor(val) {
            const obj = canvas.getActiveObject();
            if (!obj) return;

            const applyStroke = (target) => {
                if (target.isTextStrokeGroup) {
                    const parts = getTextStrokeGroupParts(target);
                    if (parts && parts.stroke) {
                        parts.stroke.set('stroke', val);
                        target.textStrokeColor = val;
                        setObjectColorData(parts.stroke, 'stroke', val);
                        parts.stroke.dirty = true;
                        target.dirty = true;
                    }
                } else {
                    target.set('stroke', val);
                    setObjectColorData(target, 'stroke', val);
                }
            };

            if (obj.type === 'activeSelection') {
                obj.forEachObject(applyStroke);
            } else {
                applyStroke(obj);
            }

            document.getElementById('stroke-swatch').style.background = val;
            canvas.renderAll();
            saveHistory();
        }

        function changeStrokeWidth(valPx) {
            const obj = canvas.getActiveObject();
            if (!obj) return;

            const px = parseFloat(valPx);
            if (obj.type === 'activeSelection') {
                obj.forEachObject(o => applyStrokeWidth(o, px));
            } else {
                applyStrokeWidth(obj, px);
            }
            const widthInput = document.getElementById('stroke-width-input');
            if (widthInput) widthInput.value = Math.max(1, px);
            canvas.renderAll();
            saveHistory();
        }

        function changeStrokeDashed() {
            const obj = canvas.getActiveObject();
            if (!obj) return;

            const checked = document.getElementById('stroke-dashed').checked;
            const dashSettings = document.getElementById('dash-settings');

            const target = obj.isTextStrokeGroup ? getTextStrokeGroupParts(obj)?.stroke : obj;
            if (!target) return;

            if (checked) {
                const rawLen = parseInt(document.getElementById('dash-length').value) || 0;
                const rawGap = parseInt(document.getElementById('dash-gap').value) || 0;
                const dashLen = Math.max(1, rawLen || rawGap || 8);
                const dashGap = Math.max(1, rawGap || rawLen || 4);
                target.set('strokeDashArray', [dashLen, dashGap]);
                target._userStrokeDashed = true;
                target._dashLength = dashLen;
                target._dashGap = dashGap;
                dashSettings.style.display = 'flex';
            } else {
                target.set('strokeDashArray', null);
                target._userStrokeDashed = false;
                dashSettings.style.display = 'none';
            }
            // Mark as dirty to force re-render for text stroke groups
            if (obj.isTextStrokeGroup) {
                target.dirty = true;
                obj.dirty = true;
            }
            canvas.renderAll();
            saveHistory();
        }

        function toggleShadow() {
            const obj = canvas.getActiveObject();
            if (!obj) return;

            const isEnabled = document.getElementById('shadow-enabled').checked;
            const shadowSettings = document.getElementById('shadow-settings');

            if (isEnabled) {
                const shadowColor = document.getElementById('shadow-color-swatch').style.background || 'rgba(0,0,0,0.5)';
                const blur = parseInt(document.getElementById('shadow-blur').value) || 10;
                const offsetX = parseInt(document.getElementById('shadow-offset-x').value) || 5;
                const offsetY = parseInt(document.getElementById('shadow-offset-y').value) || 5;

                const target = obj.isTextStrokeGroup ? obj : obj;
                target.set({
                    shadow: new fabric.Shadow({
                        color: shadowColor,
                        blur: blur,
                        offsetX: offsetX,
                        offsetY: offsetY
                    })
                });
                shadowSettings.style.display = 'block';
            } else {
                const target = obj.isTextStrokeGroup ? obj : obj;
                target.set('shadow', null);
                shadowSettings.style.display = 'none';
            }

            canvas.renderAll();
            saveHistory();
        }

        function changeShadowColor(val) {
            const obj = canvas.getActiveObject();
            if (!obj) return;

            const target = obj.isTextStrokeGroup ? obj : obj;
            if (!target.shadow) return;

            target.shadow.color = val;
            document.getElementById('shadow-color-swatch').style.background = val;
            canvas.renderAll();
            saveHistory();
        }

        function changeShadowBlur(val) {
            const obj = canvas.getActiveObject();
            if (!obj) return;

            const target = obj.isTextStrokeGroup ? obj : obj;
            if (!target.shadow) return;

            target.shadow.blur = parseInt(val);
            document.getElementById('shadow-blur-val').innerText = val;
            canvas.renderAll();
            saveHistory();
        }

        function changeShadowOffsetX(val) {
            const obj = canvas.getActiveObject();
            if (!obj) return;

            const target = obj.isTextStrokeGroup ? obj : obj;
            if (!target.shadow) return;

            target.shadow.offsetX = parseInt(val);
            document.getElementById('shadow-offset-x-val').innerText = val;
            canvas.renderAll();
            saveHistory();
        }

        function changeShadowOffsetY(val) {
            const obj = canvas.getActiveObject();
            if (!obj) return;

            const target = obj.isTextStrokeGroup ? obj : obj;
            if (!target.shadow) return;

            target.shadow.offsetY = parseInt(val);
            document.getElementById('shadow-offset-y-val').innerText = val;
            canvas.renderAll();
            saveHistory();
        }

        function applyStrokeWidth(obj, px) {
            if (!obj) return;
            const strokePx = Math.max(0, px || 0);

            const applyTo = (target) => {
                // Handle text stroke groups - convert back to simple text with stroke
                if (target.isTextStrokeGroup) {
                    const parts = getTextStrokeGroupParts(target);
                    if (!parts || !parts.fill) return;
                    const fillText = parts.fill;
                    const center = target.getCenterPoint();

                    // Extract text properties
                    const textProps = {
                        text: fillText.text,
                        fontFamily: fillText.fontFamily,
                        fontSize: fillText.fontSize,
                        fontWeight: fillText.fontWeight,
                        fontStyle: fillText.fontStyle,
                        fill: fillText.fill,
                        textAlign: fillText.textAlign,
                        lineHeight: fillText.lineHeight,
                        charSpacing: fillText.charSpacing,
                        underline: fillText.underline,
                        linethrough: fillText.linethrough,
                        overline: fillText.overline,
                        angle: target.angle,
                        scaleX: target.scaleX,
                        scaleY: target.scaleY,
                        stroke: strokePx > 0 ? (target.textStrokeColor || '#000000') : null,
                        strokeWidth: strokePx,  // Use actual pixel value
                        strokeUniform: true,
                        strokeLineCap: 'round',
                        strokeLineJoin: 'round',
                        paintFirst: 'stroke'  // Paint stroke first, then fill on top
                    };

                    // Create new text with native stroke
                    const newText = new fabric.IText(textProps.text, textProps);
                    ensureObjectId(newText);
                    canvas.remove(target);
                    canvas.add(newText);
                    newText.setPositionByOrigin(center, 'center', 'center');
                    newText.setCoords();
                    canvas.setActiveObject(newText);
                    canvas.renderAll();
                    return;
                }

                // Handle regular text objects
                if (isTextObject(target)) {
                    if (strokePx === 0) {
                        target.set({
                            stroke: null,
                            strokeWidth: 0
                        });
                    } else {
                        const strokeColor = target.stroke || document.getElementById('stroke-swatch').style.background || '#000000';
                        target.set({
                            stroke: strokeColor,
                            strokeWidth: strokePx,  // Use actual pixel value
                            strokeUniform: true,
                            strokeLineCap: 'round',
                            strokeLineJoin: 'round',
                            paintFirst: 'stroke'  // Paint stroke first, then fill on top
                        });
                    }
                    target.setCoords();
                    canvas.renderAll();
                    return;
                }

                // Handle non-text objects (shapes, etc.)
                const preservedDashArray = target.strokeDashArray;
                target.set('strokeUniform', true);
                target.set('paintFirst', 'fill');
                target.set('strokeWidth', strokePx);

                if (preservedDashArray) {
                    target.set('strokeDashArray', preservedDashArray);
                }
                target.setCoords();
            };

            if (obj._objects) {
                obj.forEachObject(child => applyTo(child));
            } else {
                applyTo(obj);
            }
            canvas.renderAll();
            saveHistory();
        }

        function setObjectColorData(obj, target, color) {
            if (!obj || !color || color === 'transparent') return;
            const rgba = colorToRgba(color);
            const cmyk = rgbToCmyk(rgba.r, rgba.g, rgba.b);
            const data = {
                colorMode: 'cmyk',
                cmyk: { ...cmyk },
                rgb: { r: rgba.r, g: rgba.g, b: rgba.b }
            };
            obj[`${target}ColorData`] = data;
        }

        function changeCornerRadius(val) {
            const obj = canvas.getActiveObject();
            if (obj && obj.type === 'rect') {
                obj.set({ rx: parseFloat(val), ry: parseFloat(val) });
                document.getElementById('corner-radius-val').innerText = val;
                canvas.renderAll();
                saveHistory();
            }
        }

        function changeObjectOpacity(val) {
            const active = canvas.getActiveObject();
            if (!active) return;
            const opacity = val / 100;
            if (active.type === 'activeSelection') {
                active.forEachObject(o => o.set('opacity', opacity));
            } else {
                active.set('opacity', opacity);
            }
            document.getElementById('global-opacity-val').innerText = val;
            canvas.renderAll();
        }

        const FONT_WEIGHT_MAP = {
            'Pretendard': ['400', '500', '700', '900'],
            'Noto Sans KR': ['400', '700'],
            'Noto Serif KR': ['400', '700'],
            'Nanum Gothic': ['400', '700'],
            'Nanum Myeongjo': ['400', '700'],
            'Black Han Sans': ['400'],
            'Do Hyeon': ['400'],
            'Gowun Dodum': ['400'],
            'Inter': ['400', '700'],
            'Roboto': ['400', '700'],
            'Arial': ['400', '700'],
            'Georgia': ['400', '700'],
            '__default': ['400', '700']
        };

        function ensureFontWeight(family, weight) {
            const list = FONT_WEIGHT_MAP[family] || FONT_WEIGHT_MAP['__default'];
            const normalized = (weight || '400').toString();
            return list.includes(normalized) ? normalized : list[0];
        }

        function setFontWeightOptions(family, currentWeight) {
            const select = document.getElementById('font-weight');
            const labels = {
                '100': 'Thin (100)',
                '300': 'Light (300)',
                '400': 'Regular (400)',
                '500': 'Medium (500)',
                '700': 'Bold (700)',
                '900': 'Black (900)'
            };
            const weights = FONT_WEIGHT_MAP[family] || FONT_WEIGHT_MAP['__default'];
            const chosen = ensureFontWeight(family, currentWeight);
            if (!select) return chosen;
            select.innerHTML = '';
            weights.forEach(w => {
                const opt = document.createElement('option');
                opt.value = w;
                opt.innerText = labels[w] || w;
                select.appendChild(opt);
            });
            select.value = chosen;
            return chosen;
        }

        function updateTypography(prop, val) {
            const active = canvas.getActiveObject();
            if (!active) return;

            let normalizedWeight = null;
            if (prop === 'fontFamily') {
                normalizedWeight = setFontWeightOptions(val, active.fontWeight || '400');
            }

            const applyTypography = (o) => {
                if (!isTextObject(o)) return;
                if (prop === 'fontSize' || prop === 'charSpacing') {
                    o.set(prop, parseFloat(val));
                } else if (prop === 'lineHeight') {
                    o.set(prop, parseFloat(val));
                } else if (prop === 'fontFamily') {
                    o.set(prop, val);
                    if (normalizedWeight) o.set('fontWeight', normalizedWeight);
                } else if (prop === 'fontWeight') {
                    const safeWeight = ensureFontWeight(o.fontFamily || active.fontFamily || 'Pretendard', val);
                    o.set('fontWeight', safeWeight);
                } else {
                    o.set(prop, val);
                }
                o.dirty = true;
                if (o.initDimensions) o.initDimensions();
                if (o.setCoords) o.setCoords();
            };

            const update = (o) => {
                if (o.isTextStrokeGroup) {
                    const parts = getTextStrokeGroupParts(o);
                    if (!parts) return;
                    applyTypography(parts.fill);
                    applyTypography(parts.stroke);
                    if (o._calcBounds) o._calcBounds();
                    if (o._updateObjectsCoords) o._updateObjectsCoords();
                    if (o.setCoords) o.setCoords();
                    return;
                }
                applyTypography(o);
            };

            if (active.type === 'activeSelection') {
                active.forEachObject(update);
            } else {
                update(active);
            }

            canvas.renderAll();
            saveHistory();
        }

        const customFonts = new Map();

        function handleFontUpload(input) {
            const file = input.files[0];
            if (!file) return;
            const allowed = ['ttf', 'otf'];
            const ext = (file.name.split('.').pop() || '').toLowerCase();
            if (!allowed.includes(ext)) {
                alert('지원되지 않는 글꼴 형식입니다. .ttf 또는 .otf 파일을 사용해주세요.');
                input.value = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = async function (e) {
                const fontName = file.name.split('.')[0].replace(/\s+/g, '_');
                const fontData = e.target.result;

                try {
                    const fontFace = new FontFace(fontName, `url(${fontData}) format("${ext === 'otf' ? 'opentype' : 'truetype'}")`);
                    await fontFace.load();
                    document.fonts.add(fontFace);

                    // Add to dropdown
                    const sel = document.getElementById('font-family');
                    const opt = document.createElement('option');
                    opt.value = fontName;
                    opt.innerText = `Custom: ${file.name}`;
                    sel.add(opt);
                    sel.value = fontName;
                    const chosenWeight = setFontWeightOptions(fontName, '400');
                    document.getElementById('font-weight').value = chosenWeight;

                    // Store for PDF export (jsPDF needs base64)
                    const base64 = fontData.split(',')[1];
                    customFonts.set(fontName, { name: fontName, data: base64, file: file.name });

                    updateTypography('fontFamily', fontName);
                    alert(`글꼴 '${file.name}'이 업로드되었습니다.`);
                } catch (err) {
                    console.error('Font Load Error:', err);
                    alert('글꼴을 불러오는 중 오류가 발생했습니다. 지원되는 .ttf / .otf 파일인지 확인해주세요.');
                }
            };
            reader.readAsDataURL(file);
        }
        function changeFontFamily(val) {
            const obj = canvas.getActiveObject();
            if (obj && obj.set) { obj.set('fontFamily', val); canvas.renderAll(); }
        }

        function toggleGradientMode() {
            const panel = document.getElementById('gradient-panel');
            const solid = document.getElementById('solid-color-panel');
            const isGradient = document.getElementById('gradient-check').checked;
            panel.style.display = isGradient ? 'block' : 'none';
            solid.style.display = isGradient ? 'none' : 'block';
            if (isGradient) {
                updateGradientType();
                updateGradient();
            }
            else changeFillColor(document.getElementById('fill-color-hex').value || '#3B82F6');
        }

        function updateGradientType() {
            const type = document.getElementById('grad-type').value;
            document.getElementById('grad-angle-row').style.display = (type === 'linear') ? 'flex' : 'none';
            updateGradient();
        }

        function updateGradient() {
            const obj = canvas.getActiveObject();
            if (!obj) return;
            const c1 = document.getElementById('grad-start-swatch').style.background;
            const c2 = document.getElementById('grad-end-swatch').style.background;

            const type = document.getElementById('grad-type').value;
            const angle = parseInt(document.getElementById('grad-angle').value);
            document.getElementById('grad-angle-val').innerText = angle + '°';

            // Store angle for persistence
            obj.gradientAngle = angle;

            let coords;
            const w = obj.width;
            const h = obj.height;

            if (type === 'linear') {
                const angleRad = (angle - 90) * (Math.PI / 180);
                // Center relative coordinates
                const cos = Math.cos(angleRad);
                const sin = Math.sin(angleRad);

                // Scale vector to fit object bounding box
                // We want the gradient to go from one edge to the other
                coords = {
                    x1: (w / 2) * (1 - cos),
                    y1: (h / 2) * (1 - sin),
                    x2: (w / 2) * (1 + cos),
                    y2: (h / 2) * (1 + sin)
                };
            } else {
                // Radial: Centered
                coords = {
                    r1: 0,
                    r2: Math.max(w, h) / 2,
                    x1: w / 2,
                    y1: h / 2,
                    x2: w / 2,
                    y2: h / 2
                };
            }

            const grad = new fabric.Gradient({
                type: type,
                gradientUnits: 'pixels',
                coords: coords,
                colorStops: [{ offset: 0, color: c1 }, { offset: 1, color: c2 }]
            });
            obj.set('fill', grad);
            canvas.renderAll();
        }

        function alignObject(dir) {
            const active = canvas.getActiveObject();
            if (!active || !artboard) return;

            const isMulti = active.type === 'activeSelection';
            const artBounds = artboard.getBoundingRect();

            // Branch: Align to selection (internal) OR Align selection/object to artboard
            if (isMulti) {
                // User requirement: "If multiple ungrouped objects, align among objects"
                // Fabric's internal alignment for ActiveSelection
                const objects = active.getObjects();
                const selBounds = active.getBoundingRect(true);

                objects.forEach(obj => {
                    const w = obj.width * obj.scaleX;
                    const h = obj.height * obj.scaleY;

                    if (dir === 'left') obj.set('left', -active.width / 2 + w / 2);
                    else if (dir === 'right') obj.set('left', active.width / 2 - w / 2);
                    else if (dir === 'center') obj.set('left', 0);
                    else if (dir === 'top') obj.set('top', -active.height / 2 + h / 2);
                    else if (dir === 'bottom') obj.set('top', active.height / 2 - h / 2);
                    else if (dir === 'middle') obj.set('top', 0);
                    obj.setCoords();
                });
            } else {
                // Single or Group: Align relative to Artboard
                const objBounds = active.getBoundingRect(true);
                const artW = artboard.width * artboard.scaleX;
                const artH = artboard.height * artboard.scaleY;

                if (dir === 'left') active.set('left', artboard.left + (active.left - objBounds.left));
                else if (dir === 'right') active.set('left', artboard.left + artW - (objBounds.width + (objBounds.left - active.left)));
                else if (dir === 'center') active.set('left', artboard.left + artW / 2 + (active.left - (objBounds.left + objBounds.width / 2)));
                else if (dir === 'top') active.set('top', artboard.top + (active.top - objBounds.top));
                else if (dir === 'bottom') active.set('top', artboard.top + artH - (objBounds.height + (objBounds.top - active.top)));
                else if (dir === 'middle') active.set('top', artboard.top + artH / 2 + (active.top - (objBounds.top + objBounds.height / 2)));

                active.setCoords();
            }

            canvas.renderAll();
            saveHistory();
        }

        function distributeObjects(dir) {
            const active = canvas.getActiveObject();
            if (!active || active.type !== 'activeSelection') return;

            const objects = active.getObjects();
            if (objects.length < 3) return;

            if (dir === 'horizontal') {
                objects.sort((a, b) => (a.left - a.getScaledWidth() / 2) - (b.left - b.getScaledWidth() / 2));
                const first = objects[0];
                const last = objects[objects.length - 1];
                const totalWidth = (last.left + last.getScaledWidth() / 2) - (first.left - first.getScaledWidth() / 2);
                const sumObjWidths = objects.reduce((sum, o) => sum + o.getScaledWidth(), 0);
                const space = (totalWidth - sumObjWidths) / (objects.length - 1);

                let currentLeft = first.left - first.getScaledWidth() / 2;
                objects.forEach(obj => {
                    const w = obj.getScaledWidth();
                    obj.set('left', currentLeft + w / 2);
                    currentLeft += w + space;
                    obj.setCoords();
                });
            } else {
                objects.sort((a, b) => (a.top - a.getScaledHeight() / 2) - (b.top - b.getScaledHeight() / 2));
                const first = objects[0];
                const last = objects[objects.length - 1];
                const totalHeight = (last.top + last.getScaledHeight() / 2) - (first.top - first.getScaledHeight() / 2);
                const sumObjHeights = objects.reduce((sum, o) => sum + o.getScaledHeight(), 0);
                const space = (totalHeight - sumObjHeights) / (objects.length - 1);

                let currentTop = first.top - first.getScaledHeight() / 2;
                objects.forEach(obj => {
                    const h = obj.getScaledHeight();
                    obj.set('top', currentTop + h / 2);
                    currentTop += h + space;
                    obj.setCoords();
                });
            }
            canvas.requestRenderAll();
            saveHistory();
        }

        function deleteSelected() {
            const active = canvas.getActiveObjects();
            if (active.length) {
                active.forEach(o => {
                    if (o.isArtboard) return;
                    canvas.remove(o);
                });
                canvas.discardActiveObject();
                canvas.renderAll();
                renderLayerList();
            }
        }

        function duplicateSelected() {
            const obj = canvas.getActiveObject();
            if (!obj) return;
            obj.clone(function (cloned) {
                canvas.discardActiveObject();
                cloned.set({
                    left: cloned.left + 20,
                    top: cloned.top + 20,
                    evented: true,
                });
                if (cloned.type === 'activeSelection') {
                    cloned.canvas = canvas;
                    cloned.forEachObject(function (obj) { canvas.add(obj); });
                    cloned.setCoords();
                } else {
                    canvas.add(cloned);
                }
                canvas.setActiveObject(cloned);
                canvas.requestRenderAll();
                renderLayerList();
            });
        }

        // --- HISTORY ---
        function saveHistory() {
            if (isUndoing) return;
            const json = {
                objects: canvas.getObjects()
                    .filter(obj => !obj.isArtboard)
                    .map(obj => obj.toObject([
                        'excludeFromExport',
                        'absolutePositioned',
                        'selectable',
                        'opacity',
                        'gradientAngle',
                        'isArtboard',
                        'isArtboardClip',
                        'isMask',
                        'isMaskGroup',
                        'maskTargetId',
                        'customId',
                        'fillColorData',
                        'strokeColorData',
                        '_userStrokeDashed',
                        '_dashLength',
                        '_dashGap',
                        '_strokeOutsideWidth',
                        '_strokeBaseWidth',
                        '_strokeBaseHeight',
                    '_strokeBaseRadius',
                    'isTextStrokeGroup',
                    'textStrokeWidth',
                    'textStrokeColor',
                    'isTextStrokeOutline',
                    'isTextFill',
                    'isFrameGroup',
                    'frameTargetId',
                    'isFrameShape',
                    'isFrameContent',
                    'objectCaching',
                    'isMaskGroup',
                    'isMask',
                    'maskTargetId',
                    '_maskBoundsNormalized',
                    '_frameBoundsNormalized'
                ]))
            };
            history = history.slice(0, historyStep + 1);
            history.push(JSON.stringify(json));
            historyStep++;
        }

        function restoreHistory(step) {
            const data = JSON.parse(history[step]);
            isUndoing = true;
            const preservedArtboard = artboard;
            const objectsToRemove = canvas.getObjects().filter(obj => !obj.isArtboard);
            objectsToRemove.forEach(obj => canvas.remove(obj));

            // Enliven objects first (waits for images) then rebuild masks; artboard stays immutable.
            fabric.util.enlivenObjects(data.objects || [], (enlivenedObjects) => {
                enlivenedObjects.forEach(obj => {
                    if (obj.excludeFromExport) obj.selectable = false;
                    ensureObjectId(obj);
                    canvas.add(obj);
                });

                if (preservedArtboard) {
                    preservedArtboard.selectable = false;
                    preservedArtboard.evented = false;
                    preservedArtboard.absolutePositioned = true;
                    preservedArtboard.sendToBack();
                }

                canvas.discardActiveObject();

                // CRITICAL: Rebuild structures BEFORE rendering
                // to avoid cache corruption
                rebuildMasksAfterLoad(canvas);
                rebuildFramesAfterLoad(canvas);
                rebuildTextStrokeGroups(canvas);
                isUndoing = false;

                // Now render with all structures properly set up
                canvas.getObjects().forEach(o => updateObjectClipping(o));
                checkCanvasBoundaries();
                canvas.renderAll();
                hideFloatingToolbar();
                renderLayerList();
            });
        }

        function undo() {
            if (historyStep <= 0) return;
            historyStep--;
            restoreHistory(historyStep);
        }

        function redo() {
            if (historyStep >= history.length - 1) return;
            historyStep++;
            restoreHistory(historyStep);
        }

        // --- EXPORT ---
        async function exportToPDF() {
            const loading = document.getElementById('loading');
            loading.classList.add('show');
            loading.innerText = '폰트 로딩 중...';

            try {
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF({
                    orientation: currentWidth > currentHeight ? 'l' : 'p',
                    unit: 'mm',
                    format: [currentWidth, currentHeight],
                    putOnlyUsedFonts: true
                });

                // Load font for text-to-outline conversion
                const font = await getOpentypeFont('Pretendard');

                const objects = canvas.getObjects().filter(o => !o.excludeFromExport && o.visible);
                const artRect = artboard.getBoundingRect(true);
                const total = objects.length;

                for (let i = 0; i < total; i++) {
                    const obj = objects[i];
                    loading.innerText = `처리 중 (${i + 1}/${total})...`;
                    // Small delay to prevent UI freeze
                    if (i % 5 === 0) await new Promise(r => setTimeout(r, 0));
                    await drawObjectToPDF(pdf, obj, artRect, font);
                }

                loading.innerText = 'PDF 저장 중...';
                pdf.save(`디자인-${Date.now()}.pdf`);
            } catch (err) {
                console.error('PDF Export Error:', err);
                alert('PDF 내보내기 중 오류가 발생했습니다: ' + err.message);
            } finally {
                loading.classList.remove('show');
                loading.innerText = '처리 중...';
            }
        }

        function applyStylesToPDF(pdf, obj) {
            if (obj.fill && obj.fill !== 'transparent' && obj.type !== 'line') {
                pdf.setFillColor(obj.fill);
            }
            if (obj.stroke && obj.strokeWidth > 0) {
                pdf.setDrawColor(obj.stroke);
                pdf.setLineWidth(obj.strokeWidth * obj.scaleX / MM_TO_PX_SCREEN);
            }
        }

        function renderPathToPDF(pdf, pathData, sx, sy, ox, oy) {
            pathData.forEach(cmd => {
                const type = cmd[0];
                if (type === 'M') pdf.moveTo(ox + cmd[1] * sx, oy + cmd[2] * sy);
                else if (type === 'L') pdf.lineTo(ox + cmd[1] * sx, oy + cmd[2] * sy);
                else if (type === 'C') pdf.curveTo(ox + cmd[1] * sx, oy + cmd[2] * sy, ox + cmd[3] * sx, oy + cmd[4] * sy, ox + cmd[5] * sx, oy + cmd[6] * sy);
                else if (type === 'Q') {
                    const x = ox + cmd[1] * sx; const y = oy + cmd[2] * sy;
                    const xT = ox + cmd[3] * sx; const yT = oy + cmd[4] * sy;
                    pdf.curveTo(x, y, x, y, xT, yT);
                }
                else if (type === 'Z') pdf.close();
            });
        }

        async function drawTextAsOutlines(pdf, obj, font, options = {}) {
            if (!font) return;
            const { fill = true, stroke = false } = options;
            const text = obj.text || '';
            const lines = text.split('\n');
            const fs = obj.fontSize;
            const lh = obj.fontSize * (obj.lineHeight || 1.16);
            if (fill && obj.fill && obj.fill !== 'transparent') {
                const rgba = colorToRgba(obj.fill);
                pdf.setFillColor(rgba.r, rgba.g, rgba.b);
            }
            if (stroke && obj.stroke && obj.strokeWidth > 0) {
                const rgba = colorToRgba(obj.stroke);
                pdf.setDrawColor(rgba.r, rgba.g, rgba.b);
                pdf.setLineWidth((obj.strokeWidth * obj.scaleX) / MM_TO_PX_SCREEN);
            } else if (stroke) {
                pdf.setLineWidth(0);
            }
            lines.forEach((line, i) => {
                const lp = font.getPath(line, 0, (i + 0.8) * lh, fs);
                const cmds = lp.commands.map(c => {
                    if (c.type === 'M') return ['M', c.x, c.y];
                    if (c.type === 'L') return ['L', c.x, c.y];
                    if (c.type === 'C') return ['C', c.x1, c.y1, c.x2, c.y2, c.x, c.y];
                    if (c.type === 'Q') return ['Q', c.x1, c.y1, c.x, c.y];
                    if (c.type === 'Z') return ['Z'];
                    return null;
                }).filter(Boolean);
                const sx = obj.scaleX / MM_TO_PX_SCREEN;
                const sy = obj.scaleY / MM_TO_PX_SCREEN;
                const ox = - (obj.getScaledWidth() / 2) / MM_TO_PX_SCREEN;
                const oy = - (obj.getScaledHeight() / 2) / MM_TO_PX_SCREEN;
                renderPathToPDF(pdf, cmds, sx, sy, ox, oy);
                if (fill && stroke) {
                    pdf.fillStroke();
                } else if (fill) {
                    pdf.fill();
                } else if (stroke) {
                    pdf.stroke();
                }
            });
        }

        async function drawObjectToPDF(pdf, obj, artRect, font) {
            const center = obj.getCenterPoint();
            const x = (center.x - artRect.left) / MM_TO_PX_SCREEN;
            const y = (center.y - artRect.top) / MM_TO_PX_SCREEN;
            const angle = obj.angle || 0;
            const opacity = obj.opacity !== undefined ? obj.opacity : 1;

            pdf.saveGraphicsState();

            // Set opacity via GState if needed
            if (opacity < 1) {
                pdf.setGState(new pdf.GState({ opacity: opacity, "stroke-opacity": opacity }));
            }

            // Move to center and rotate
            pdf.setTransform(1, 0, 0, 1, x, y);
            if (angle !== 0) {
                const rad = angle * Math.PI / 180;
                pdf.setTransform(Math.cos(rad), Math.sin(rad), -Math.sin(rad), Math.cos(rad), x, y);
            }

            // Draw based on type
            const w = (obj.width * obj.scaleX) / MM_TO_PX_SCREEN;
            const h = (obj.height * obj.scaleY) / MM_TO_PX_SCREEN;

            if (obj.type === 'rect' || obj.type === 'circle' || obj.type === 'triangle' || obj.type === 'path' || obj.type === 'line') {
                applyStylesToPDF(pdf, obj);
                if (obj.type === 'rect') {
                    if (obj.rx || obj.ry) {
                        const r = (obj.rx || obj.ry) * obj.scaleX / MM_TO_PX_SCREEN;
                        pdf.roundedRect(-w / 2, -h / 2, w, h, r, r, 'FD');
                    } else {
                        pdf.rect(-w / 2, -h / 2, w, h, 'FD');
                    }
                } else if (obj.type === 'circle') {
                    pdf.ellipse(0, 0, w / 2, h / 2, 'FD');
                } else if (obj.type === 'triangle') {
                    pdf.triangle(-w / 2, h / 2, w / 2, h / 2, 0, -h / 2, 'FD');
                } else if (obj.type === 'line') {
                    // Line handling
                    const x1 = (obj.x1 * obj.scaleX - (obj.width * obj.scaleX / 2)) / MM_TO_PX_SCREEN;
                    const y1 = (obj.y1 * obj.scaleY - (obj.height * obj.scaleY / 2)) / MM_TO_PX_SCREEN;
                    const x2 = (obj.x2 * obj.scaleX - (obj.width * obj.scaleX / 2)) / MM_TO_PX_SCREEN;
                    const y2 = (obj.y2 * obj.scaleY - (obj.height * obj.scaleY / 2)) / MM_TO_PX_SCREEN;
                    pdf.line(x1, y1, x2, y2);
                    pdf.stroke();
                } else if (obj.type === 'path') {
                    if (obj.path && Array.isArray(obj.path)) {
                        const sx = obj.scaleX / MM_TO_PX_SCREEN;
                        const sy = obj.scaleY / MM_TO_PX_SCREEN;
                        const ox = - (obj.width * obj.scaleX / 2) / MM_TO_PX_SCREEN;
                        const oy = - (obj.height * obj.scaleY / 2) / MM_TO_PX_SCREEN;

                        obj.path.forEach(cmd => {
                            const type = cmd[0];
                            if (type === 'M') pdf.moveTo(ox + cmd[1] * sx, oy + cmd[2] * sy);
                            else if (type === 'L') pdf.lineTo(ox + cmd[1] * sx, oy + cmd[2] * sy);
                            else if (type === 'C') pdf.curveTo(ox + cmd[1] * sx, oy + cmd[2] * sy, ox + cmd[3] * sx, oy + cmd[4] * sy, ox + cmd[5] * sx, oy + cmd[6] * sy);
                            else if (type === 'Q') {
                                // Quadratic to Cubic
                                const c1x = cmd[1]; const c1y = cmd[2]; const c2x = cmd[3]; const c2y = cmd[4];
                                pdf.curveTo(ox + c1x * sx, oy + c1y * sy, ox + c1x * sx, oy + c1y * sy, ox + c2x * sx, oy + c2y * sy);
                            }
                            else if (type === 'Z') pdf.close();
                        });
                        const style = (obj.fill && obj.fill !== 'transparent') ? 'FD' : 'S';
                        pdf.fillStroke(style);
                    }
                }
            } else if (obj.type === 'group' && obj.isTextStrokeGroup) {
                const parts = getTextStrokeGroupParts(obj);
                if (parts && parts.stroke) {
                    await drawTextAsOutlines(pdf, parts.stroke, font, { fill: false, stroke: true });
                }
                if (parts && parts.fill) {
                    await drawTextAsOutlines(pdf, parts.fill, font, { fill: true, stroke: false });
                }
            } else if (obj.type === 'textbox' || obj.type === 'i-text' || obj.type === 'text') {
                // PRINT-SAFE: Convert text to vector outlines
                await drawTextAsOutlines(pdf, obj, font, { fill: true, stroke: false });
            } else if (obj.type === 'image') {
                const dataURL = obj.toDataURL({ format: 'png' });
                pdf.addImage(dataURL, 'PNG', -w / 2, -h / 2, w, h);
            }

            pdf.restoreGraphicsState();
        }

        function applyStylesToPDF(pdf, obj) {
            const fill = obj.fill;
            const stroke = obj.stroke;
            const strokeWidth = (obj.strokeWidth * obj.scaleX) / MM_TO_PX_SCREEN;

            if (fill && typeof fill === 'string' && fill !== 'transparent') {
                const rgba = colorToRgba(fill);
                pdf.setFillColor(rgba.r, rgba.g, rgba.b);
            }

            if (stroke && stroke !== 'transparent' && strokeWidth > 0) {
                const rgba = colorToRgba(stroke);
                pdf.setDrawColor(rgba.r, rgba.g, rgba.b);
                pdf.setLineWidth(strokeWidth);
            } else {
                pdf.setLineWidth(0);
            }
        }

        // --- LAYERS ---
        function renderLayerList() {
            const list = document.getElementById('regular-layer-list');
            if (!list) return; // Panel might not be visible
            list.innerHTML = '';
            // Exclude artboard
            const objects = canvas.getObjects().filter(o => !o.excludeFromExport).reverse();

            if (objects.length === 0) {
                list.innerHTML = '<div style="text-align:center; padding:20px; color:var(--text-sub); font-size:11px;">개체가 없습니다.</div>';
                return;
            }

            objects.forEach((obj, i) => {
                const actualIndex = canvas.getObjects().indexOf(obj);
                const item = document.createElement('div');
                item.className = 'layer-item';
                if (canvas.getActiveObject() === obj) item.classList.add('active');

                const isHidden = !obj.visible;
                const isLocked = obj.lockMovementX;

                // Get SVG icon based on type (Figma style)
                let iconSvg = '';
                let displayType = obj.type;

                // Text stroke groups should display as text
                if (obj.isTextStrokeGroup) {
                    displayType = 'text';
                    iconSvg = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 7V4h16v3M9 20h6M12 4v16"/></svg>';
                } else if (obj.type === 'i-text' || obj.type === 'textbox' || obj.type === 'text') {
                    iconSvg = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 7V4h16v3M9 20h6M12 4v16"/></svg>';
                } else if (obj.type === 'image') {
                    iconSvg = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><path d="M21 15l-5-5L5 21"/></svg>';
                } else if (obj.type === 'rect') {
                    iconSvg = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/></svg>';
                } else if (obj.type === 'circle') {
                    iconSvg = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/></svg>';
                } else if (obj.type === 'triangle') {
                    iconSvg = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 3l9 18H3L12 3z"/></svg>';
                } else if (obj.type === 'line') {
                    iconSvg = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="12" x2="19" y2="12"/></svg>';
                } else if (obj.type === 'path') {
                    iconSvg = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 14l-6-6m-8 0l6 6m0-6v12"/></svg>';
                } else if (obj.type === 'group') {
                    iconSvg = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/></svg>';
                } else {
                    iconSvg = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18"/></svg>';
                }

                // Lock icon
                const lockIcon = isLocked
                    ? '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>'
                    : '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2"/><path d="M7 11V7a5 5 0 0 1 9.9-1"/></svg>';

                // Visibility icon
                const visibilityIcon = isHidden
                    ? '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"/><line x1="1" y1="1" x2="23" y2="23"/></svg>'
                    : '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>';

                item.innerHTML = `
                    <div class="layer-icon">${iconSvg}</div>
                    <span class="layer-name">${obj.name || displayType}</span>
                    <div class="layer-actions">
                        <div class="layer-action-btn" title="${isLocked ? '잠금 해제' : '잠금'}" onclick="event.stopPropagation(); toggleLayerLock(${actualIndex})">${lockIcon}</div>
                        <div class="layer-action-btn" title="${isHidden ? '표시' : '숨기기'}" onclick="event.stopPropagation(); toggleLayerVisibility(${actualIndex})">${visibilityIcon}</div>
                    </div>
                `;
                item.onclick = () => {
                    if (!isLocked) {
                        canvas.setActiveObject(obj);
                        canvas.renderAll();
                    }
                    renderLayerList();
                };
                list.appendChild(item);
            });

            const content = document.getElementById('content-layers');
            if (content && !content.classList.contains('collapsed')) {
                requestAnimationFrame(() => {
                    content.style.maxHeight = content.scrollHeight + 'px';
                });
            }
        }

        function moveLayer(index, dir) {
            const obj = canvas.getObjects()[index];
            if (!obj || obj.isArtboard) return;

            const objects = canvas.getObjects();
            const artboardIndex = objects.findIndex(o => o.isArtboard);
            const minIndex = artboardIndex + 1;

            if (dir === 'up') {
                if (index < objects.length - 1) {
                    obj.bringForward();
                }
            } else if (dir === 'down') {
                if (index > minIndex) {
                    obj.sendBackwards();
                }
            } else if (dir === 'front') {
                obj.bringToFront();
            } else if (dir === 'back') {
                // Move to right after artboard
                obj.moveTo(minIndex);
            }

            // Safety: ensure artboard is always at the bottom
            const currentArtboard = canvas.getObjects().find(o => o.isArtboard);
            if (currentArtboard && canvas.getObjects().indexOf(currentArtboard) !== 0) {
                currentArtboard.sendToBack();
            }

            canvas.renderAll();
            renderLayerList();
            saveHistory();
        }

        function duplicateLayer(index) {
            const obj = canvas.getObjects()[index];
            if (!obj) return;
            canvas.setActiveObject(obj);
            duplicateSelected();
        }

        function deleteLayer(index) {
            const obj = canvas.getObjects()[index];
            if (obj) {
                if (obj.isArtboard) return;
                canvas.remove(obj);
                canvas.renderAll();
                renderLayerList();
            }
        }

        function toggleLayerVisibility(index) {
            const obj = canvas.getObjects()[index];
            if (obj) {
                obj.visible = !obj.visible;
                canvas.renderAll();
                renderLayerList();
            }
        }

        function toggleLayerLock(index) {
            const obj = canvas.getObjects()[index];
            if (obj) {
                const isLocked = !obj.lockMovementX;
                obj.set({
                    lockMovementX: isLocked,
                    lockMovementY: isLocked,
                    lockScalingX: isLocked,
                    lockScalingY: isLocked,
                    lockRotation: isLocked,
                    selectable: !isLocked,
                    hasControls: !isLocked
                });
                if (isLocked && canvas.getActiveObject() === obj) canvas.discardActiveObject();
                canvas.renderAll();
                renderLayerList();
            }
        }

        // --- UX ENHANCEMENTS ---
        function updateFloatingToolbar() {
            const obj = canvas.getActiveObject();
            const contextTools = document.getElementById('object-context-tools');

            if (!obj) {
                contextTools.style.display = 'none';
                return;
            }

            // Show context tools
            contextTools.style.display = 'flex';

            // Toggle Group/Ungroup buttons
            document.getElementById('btn-group').style.display = (obj.type === 'activeSelection') ? 'flex' : 'none';
            // Hide ungroup button for text stroke groups
            document.getElementById('btn-ungroup').style.display = (obj.type === 'group' && !obj.isTextStrokeGroup) ? 'flex' : 'none';

            // Mask buttons
            const isMulti = obj.type === 'activeSelection' && obj._objects && obj._objects.length === 2;
            document.getElementById('btn-mask').style.display = isMulti ? 'flex' : 'none';
            document.getElementById('btn-unmask').style.display = (obj.isMaskGroup || obj.isFrameGroup) ? 'flex' : 'none';
        }

        function getTransformTargets(target) {
            if (!target) return [];
            if (target.type === 'activeSelection') {
                return target.getObjects();
            }
            return [target];
        }

        function normalizeAngle(angle) {
            const normalized = ((angle % 360) + 360) % 360;
            return normalized;
        }

        function flipHorizontal(target) {
            const active = target || canvas.getActiveObject();
            const targets = getTransformTargets(active);
            if (!targets.length) return;

            targets.forEach(obj => {
                const center = obj.getCenterPoint();
                obj.set('scaleX', (obj.scaleX || 1) * -1);
                obj.setPositionByOrigin(center, 'center', 'center');
                obj.setCoords();
            });

            canvas.requestRenderAll();
            saveHistory();
        }

        function flipVertical(target) {
            const active = target || canvas.getActiveObject();
            const targets = getTransformTargets(active);
            if (!targets.length) return;

            targets.forEach(obj => {
                const center = obj.getCenterPoint();
                obj.set('scaleY', (obj.scaleY || 1) * -1);
                obj.setPositionByOrigin(center, 'center', 'center');
                obj.setCoords();
            });

            canvas.requestRenderAll();
            saveHistory();
        }

        function rotateCW(target) {
            rotateBy(target, 90);
        }

        function rotateCCW(target) {
            rotateBy(target, -90);
        }

        function rotate180(target) {
            rotateBy(target, 180);
        }

        function rotateBy(target, delta) {
            const active = target || canvas.getActiveObject();
            const targets = getTransformTargets(active);
            if (!targets.length) return;

            targets.forEach(obj => {
                const center = obj.getCenterPoint();
                const nextAngle = normalizeAngle((obj.angle || 0) + delta);
                obj.set('angle', nextAngle);
                obj.setPositionByOrigin(center, 'center', 'center');
                obj.setCoords();
            });

            canvas.requestRenderAll();
            saveHistory();
        }

        function hideFloatingToolbar() {
            document.getElementById('object-context-tools').style.display = 'none';
        }

        function moveLayerAction(dir) {
            const obj = canvas.getActiveObject();
            if (!obj) return;
            const index = canvas.getObjects().indexOf(obj);
            if (index !== -1) moveLayer(index, dir);
        }

        function groupSelected() {
            const active = canvas.getActiveObject();
            if (!active || active.type !== 'activeSelection') return;
            active.toGroup();
            canvas.requestRenderAll();
            saveHistory();
            updateFloatingToolbar();
        }

        function ungroupSelected() {
            const active = canvas.getActiveObject();
            if (!active || active.type !== 'group') return;

            // Prevent ungrouping text stroke groups
            if (active.isTextStrokeGroup) {
                console.warn('Text stroke groups cannot be ungrouped');
                return;
            }

            active.toActiveSelection();
            canvas.requestRenderAll();
            saveHistory();
            updateFloatingToolbar();
        }

        function resolveMaskPairFromSelection(selectionObjects) {
            const objectsWithOrder = selectionObjects.map(obj => ({
                obj,
                index: canvas.getObjects().indexOf(obj)
            })).sort((a, b) => a.index - b.index);

            const imageObjects = objectsWithOrder.filter(entry => entry.obj.type === 'image');
            if (imageObjects.length > 1) {
                alert('이미지 마스크는 하나의 이미지와 하나의 도형만 지원합니다.');
                return null;
            }

            const maskCandidates = objectsWithOrder.filter(entry => !['image', 'line'].includes(entry.obj.type));
            if (maskCandidates.length === 0) {
                alert('마스크는 선이나 이미지가 아닌 도형을 선택해주세요.');
                return null;
            }

            let target = null;
            let mask = null;
            if (imageObjects.length === 1) {
                target = imageObjects[0].obj;
                mask = maskCandidates.find(entry => entry.obj !== target)?.obj || null;
            } else {
                mask = maskCandidates[maskCandidates.length - 1].obj;
                target = objectsWithOrder.find(entry => entry.obj !== mask)?.obj || null;
            }

            if (!target || !mask) return null;
            return { mask, target };
        }

        function getMaskObjectFromGroup(group) {
            return group._objects.find(child => child.isMask) || group._objects[0];
        }

        function getEffectiveBounds(obj) {
            if (!obj) return null;
            if (obj.type === 'activeSelection') return getObjectBounds(obj);
            if (obj.isFrameGroup) {
                return getObjectBounds(obj);
            }
            if (obj.isMaskGroup) {
                const mask = getMaskObjectFromGroup(obj);
                if (mask) return getObjectBounds(mask);
            }
            return getObjectBounds(obj);
        }

        function normalizeObjectToCenter(obj) {
            if (!obj) return;
            const center = obj.getCenterPoint();
            obj.set({
                originX: 'center',
                originY: 'center'
            });
            obj.setPositionByOrigin(center, 'center', 'center');
            obj.setCoords();
        }

        function getFrameParts(group) {
            if (!group || !group.isFrameGroup) return null;
            const contentImage = group._objects.find(child => child.isFrameContent) || group._objects[0];
            const frameShape = group._objects.find(child => child.isFrameShape) || group._objects[1];
            return { frameShape, contentImage };
        }

        function normalizeMaskGroupBounds(group, anchorPoint) {
            if (!group || !group.isMaskGroup) return;
            if (group._maskBoundsNormalized) return;

            // Force group bounds to follow mask geometry (Figma/Illustrator behavior).
            group._calcBounds = function (onlySet) {
                const mask = getMaskObjectFromGroup(this);
                if (!mask) {
                    fabric.Group.prototype._calcBounds.call(this, onlySet);
                    return;
                }

                const objects = this._objects;
                this._objects = [mask];
                fabric.Group.prototype._calcBounds.call(this, onlySet);
                this._objects = objects;
            };

            group._maskBoundsNormalized = true;
            const mask = getMaskObjectFromGroup(group);
            const center = anchorPoint || (mask ? mask.getCenterPoint() : group.getCenterPoint());
            group._calcBounds();
            group._updateObjectsCoords();
            group.setPositionByOrigin(center, 'center', 'center');
            group._updateObjectsCoords();
            group.setCoords();
        }

        function normalizeFrameGroupBounds(group, anchorPoint) {
            if (!group || !group.isFrameGroup) return;
            if (group._frameBoundsNormalized) return;

            group._calcBounds = function (onlySet) {
                const parts = getFrameParts(this);
                if (!parts || !parts.frameShape) {
                    fabric.Group.prototype._calcBounds.call(this, onlySet);
                    return;
                }

                const objects = this._objects;
                this._objects = [parts.frameShape];
                fabric.Group.prototype._calcBounds.call(this, onlySet);
                this._objects = objects;
            };

            group._frameBoundsNormalized = true;
            const center = anchorPoint || group.getCenterPoint();
            group._calcBounds();
            group._updateObjectsCoords();
            group.setPositionByOrigin(center, 'center', 'center');
            group._updateObjectsCoords();
            group.setCoords();
        }

        function rebuildMasksAfterLoad(targetCanvas) {
            const allObjects = targetCanvas.getObjects();
            allObjects.forEach(obj => {
                if (obj.isMaskGroup) {
                    const mask = obj._objects.find(child => child.isMask) || obj._objects[0];
                    const target = obj._objects.find(child => !child.isMask) || obj._objects[1];

                    if (mask) {
                        normalizeObjectToCenter(mask);
                        mask.set({
                            isMask: true,
                            selectable: false,
                            evented: false,
                            opacity: 0
                        });
                        mask.maskTargetId = obj.maskTargetId || (target && target.customId) || null;
                    }

                    if (target) {
                        normalizeObjectToCenter(target);
                        ensureObjectId(target);
                        obj.maskTargetId = target.customId;
                    }

                    obj.subTargetCheck = true;
                    const maskCenter = mask ? mask.getCenterPoint() : null;
                    normalizeMaskGroupBounds(obj, maskCenter);
                }
            });
        }

        function rebuildFramesAfterLoad(targetCanvas) {
            targetCanvas.getObjects().forEach(obj => {
                if (!obj.isFrameGroup) return;
                const parts = getFrameParts(obj);
                if (!parts) return;
                const { frameShape, contentImage } = parts;
                if (frameShape) {
                    frameShape.set({
                        selectable: false,
                        evented: false
                    });
                    frameShape.isFrameShape = true;
                }
                if (contentImage) {
                    contentImage.set({
                        selectable: false,
                        evented: false
                    });
                    contentImage.isFrameContent = true;
                }
                obj.subTargetCheck = true;
                obj.objectCaching = false;  // CRITICAL: required for clipPath
                obj.clipPath = buildFrameClipPath(frameShape);  // CORRECTED: use clipPath
                normalizeFrameGroupBounds(obj, frameShape ? frameShape.getCenterPoint() : null);
                obj.dirty = true;  // Force re-render
            });
            targetCanvas.requestRenderAll();
        }

        function buildFrameClipPath(frameShape) {
            if (!frameShape) return null;

            // Create new clip shape based on type instead of cloning
            // This avoids clone() issues with complex objects
            let clipShape;

            if (frameShape.type === 'circle') {
                clipShape = new fabric.Circle({
                    radius: frameShape.radius,
                    scaleX: frameShape.scaleX || 1,
                    scaleY: frameShape.scaleY || 1
                });
            } else if (frameShape.type === 'rect') {
                clipShape = new fabric.Rect({
                    width: frameShape.width,
                    height: frameShape.height,
                    scaleX: frameShape.scaleX || 1,
                    scaleY: frameShape.scaleY || 1,
                    rx: frameShape.rx || 0,
                    ry: frameShape.ry || 0
                });
            } else if (frameShape.type === 'polygon' || frameShape.type === 'path') {
                // For complex shapes, use toObject/fromObject for deep copy
                clipShape = new fabric[frameShape.type.charAt(0).toUpperCase() + frameShape.type.slice(1)](
                    frameShape.points || frameShape.path,
                    {
                        scaleX: frameShape.scaleX || 1,
                        scaleY: frameShape.scaleY || 1
                    }
                );
            } else {
                // Fallback: try clone for other types
                clipShape = fabric.util.object.clone(frameShape);
            }

            clipShape.set({
                left: 0,
                top: 0,
                originX: 'center',
                originY: 'center',
                absolutePositioned: false,  // CRITICAL: relative to group
                fill: 'transparent',
                stroke: null,
                strokeWidth: 0
            });

            return clipShape;
        }

        function createMaskGroup(maskShape, targetObject) {
            // 1) Capture world center BEFORE removing anything from canvas.
            const worldCenter = targetObject.getCenterPoint();

            // 2) Normalize to local coordinates (centered at 0,0) before grouping.
            maskShape.set({ left: 0, top: 0, originX: 'center', originY: 'center' });
            targetObject.set({ left: 0, top: 0, originX: 'center', originY: 'center' });

            // 3) Create group at the captured world center.
            const group = new fabric.Group([maskShape, targetObject], {
                left: worldCenter.x,
                top: worldCenter.y,
                originX: 'center',
                originY: 'center',
                subTargetCheck: true,
                selectable: true,
                evented: true
            });
            group.isMaskGroup = true;
            group.maskTargetId = targetObject.customId;

            // 4) Normalize bounds to mask geometry after group creation.
            normalizeMaskGroupBounds(group, worldCenter);

            // 5) Finalize bounds and coords with no intermediate renders.
            group._calcBounds();
            group._updateObjectsCoords();
            group.setCoords();

            return group;
        }

        function createFrame(frameShape, contentImage) {
            // 1) Capture world centers BEFORE removing anything from canvas.
            const frameCenter = frameShape.getCenterPoint();
            const imageCenter = contentImage.getCenterPoint();

            // 2) Normalize local coordinates for stable grouping.
            frameShape.set({ left: 0, top: 0, originX: 'center', originY: 'center' });

            // 3) Build group anchored to captured frame center.
            const group = new fabric.Group([contentImage, frameShape], {
                left: frameCenter.x,
                top: frameCenter.y,
                originX: 'center',
                originY: 'center',
                subTargetCheck: true,
                selectable: true,
                evented: true,
                objectCaching: false  // CRITICAL: required for clipPath to render correctly
            });
            group.isFrameGroup = true;
            group.frameTargetId = contentImage.customId;

            frameShape.isFrameShape = true;
            frameShape.selectable = false;
            frameShape.evented = false;

            contentImage.isFrameContent = true;
            contentImage.selectable = false;
            contentImage.evented = false;

            // CORRECT APPROACH: Use clipPath, not clipTo
            group.clipPath = buildFrameClipPath(frameShape);

            normalizeFrameGroupBounds(group, frameCenter);
            group.setCoords();

            // 4) Restore content image's original world center inside the group.
            const groupMatrix = group.calcTransformMatrix();
            const inverted = fabric.util.invertTransform(groupMatrix);
            const imageLocal = fabric.util.transformPoint(imageCenter, inverted);
            contentImage.set({
                left: imageLocal.x,
                top: imageLocal.y,
                originX: 'center',
                originY: 'center'
            });
            contentImage.setCoords();
            group.setCoords();

            return group;
        }

        function constrainFrameContent(frameGroup, contentImage) {
            const parts = getFrameParts(frameGroup);
            if (!parts) return;
            const frameRect = parts.frameShape.getBoundingRect(true, true);
            const imageRect = contentImage.getBoundingRect(true, true);

            let shiftX = 0;
            let shiftY = 0;
            if (imageRect.left > frameRect.left) shiftX = frameRect.left - imageRect.left;
            if (imageRect.top > frameRect.top) shiftY = frameRect.top - imageRect.top;
            if (imageRect.left + imageRect.width < frameRect.left + frameRect.width) {
                shiftX = frameRect.left + frameRect.width - (imageRect.left + imageRect.width);
            }
            if (imageRect.top + imageRect.height < frameRect.top + frameRect.height) {
                shiftY = frameRect.top + frameRect.height - (imageRect.top + imageRect.height);
            }

            if (shiftX === 0 && shiftY === 0) return;

            const inverted = fabric.util.invertTransform(frameGroup.calcTransformMatrix());
            const delta = fabric.util.transformPoint(new fabric.Point(shiftX, shiftY), inverted);
            contentImage.set({
                left: contentImage.left + delta.x,
                top: contentImage.top + delta.y
            });
            contentImage.setCoords();
            frameGroup._updateObjectsCoords();
            frameGroup.setCoords();
        }

        function enterImageEditMode(frameGroup) {
            if (!frameGroup || !frameGroup.isFrameGroup) return;
            const parts = getFrameParts(frameGroup);
            if (!parts || !parts.contentImage) return;
            frameGroup.isEditingImage = true;
            parts.contentImage.set({ selectable: true, evented: true });
            frameGroup.set({ selectable: false, evented: false });
            canvas.setActiveObject(parts.contentImage);
        }

        function exitImageEditMode(frameGroup) {
            if (!frameGroup || !frameGroup.isFrameGroup) return;
            const parts = getFrameParts(frameGroup);
            if (!parts || !parts.contentImage) return;
            frameGroup.isEditingImage = false;
            parts.contentImage.set({ selectable: false, evented: false });
            frameGroup.set({ selectable: true, evented: true });
            canvas.setActiveObject(frameGroup);
        }
        function rebuildTextStrokeGroups(targetCanvas) {
            // Convert old text stroke groups to new native stroke format
            const objectsToConvert = [];

            targetCanvas.getObjects().forEach(obj => {
                if (!obj.isTextStrokeGroup || obj.type !== 'group') return;

                const parts = getTextStrokeGroupParts(obj);
                if (!parts) return;

                const { stroke, fill } = parts;
                if (!fill) return;

                // Extract properties from old group
                const strokePx = obj.textStrokeWidth || 0;
                const strokeColor = obj.textStrokeColor || (stroke ? stroke.stroke : '#000000');

                // Create new text object with native stroke
                const newText = new fabric.Text(fill.text || '', {
                    left: obj.left,
                    top: obj.top,
                    originX: obj.originX || 'left',
                    originY: obj.originY || 'top',
                    fontFamily: fill.fontFamily,
                    fontSize: fill.fontSize,
                    fontWeight: fill.fontWeight,
                    fontStyle: fill.fontStyle,
                    fill: fill.fill,
                    textAlign: fill.textAlign,
                    angle: obj.angle,
                    scaleX: obj.scaleX,
                    scaleY: obj.scaleY,
                    opacity: obj.opacity,
                    // Native stroke properties
                    stroke: strokePx > 0 ? strokeColor : null,
                    strokeWidth: strokePx,
                    strokeUniform: true,
                    strokeLineCap: 'round',
                    strokeLineJoin: 'round',
                    paintFirst: 'stroke',
                    // Preserve metadata
                    customId: obj.customId,
                    selectable: obj.selectable,
                    evented: obj.evented,
                    excludeFromExport: obj.excludeFromExport
                });

                objectsToConvert.push({ old: obj, new: newText });
            });

            // Replace old groups with new text objects
            objectsToConvert.forEach(({ old, new: newText }) => {
                const index = targetCanvas.getObjects().indexOf(old);
                targetCanvas.remove(old);
                targetCanvas.insertAt(newText, index, false);
            });
        }

        function maskWithShape(maskShape, targetObject) {
            if (!maskShape || !targetObject) {
                const active = canvas.getActiveObject();
                if (!active || active.type !== 'activeSelection') return;
                const selectionObjects = active.getObjects ? active.getObjects() : (active._objects || []);
                if (selectionObjects.length !== 2) {
                    alert('마스크는 두 개의 개체(대상 + 도형)만 선택했을 때 적용됩니다.');
                    return;
                }

                const resolved = resolveMaskPairFromSelection(selectionObjects);
                if (!resolved) return;
                maskShape = resolved.mask;
                targetObject = resolved.target;
            }

            if (maskShape.group || targetObject.group) {
                const group = maskShape.group || targetObject.group;
                if (group && group.isMaskGroup) {
                    alert('이미 마스크 그룹에 포함된 개체는 먼저 마스크를 해제해주세요.');
                    return;
                }
            }

            if (maskShape.type === 'image' || maskShape.type === 'line') {
                alert('마스크는 선이나 이미지가 아닌 도형을 선택해주세요.');
                return;
            }

            canvas.discardActiveObject();

            ensureObjectId(maskShape);
            ensureObjectId(targetObject);

            // Frame-based cropping: build the frame group without clipPath.
            const group = createFrame(maskShape, targetObject);

            // Only after group is fully prepared, swap objects on canvas.
            canvas.remove(maskShape);
            canvas.remove(targetObject);

            canvas.add(group);
            canvas.setActiveObject(group);
            canvas.requestRenderAll();
            renderLayerList();
            saveHistory();
            updateFloatingToolbar();
        }

        function releaseMask(maskGroup) {
            const group = maskGroup || canvas.getActiveObject();
            if (!group || (!group.isMaskGroup && !group.isFrameGroup)) return;

            const objects = group._objects || [];
            const matrix = group.calcTransformMatrix();

            const objectsWithPositions = objects.map(obj => {
                const center = obj.getCenterPoint();
                const worldCenter = fabric.util.transformPoint(center, matrix);
                return {
                    obj,
                    center: worldCenter,
                    angle: obj.angle + group.angle,
                    scaleX: obj.scaleX * group.scaleX,
                    scaleY: obj.scaleY * group.scaleY,
                    originX: obj.originX || 'center',
                    originY: obj.originY || 'center'
                };
            });

            group._objects = [];
            canvas.remove(group);

            objectsWithPositions.forEach(({ obj, center, angle, scaleX, scaleY, originX, originY }) => {
                if (obj.isFrameShape) {
                    obj.set({ selectable: true, evented: true });
                    obj.isFrameShape = false;
                }
                if (obj.isFrameContent) {
                    obj.set({ selectable: true, evented: true });
                    obj.isFrameContent = false;
                }
                if (obj.isMask) {
                    obj.set({
                        isMask: false,
                        selectable: true,
                        evented: true,
                        opacity: 1
                    });
                    obj.maskTargetId = null;
                }

                obj.group = null;
                obj.set({
                    angle,
                    scaleX,
                    scaleY
                });
                obj.setPositionByOrigin(center, originX, originY);

                obj.setCoords();
                ensureObjectId(obj);
                canvas.add(obj);
            });

            canvas.discardActiveObject();
            canvas.requestRenderAll();
            renderLayerList();
            saveHistory();
            updateFloatingToolbar();
        }

        function lockSelectedAction() {
            const obj = canvas.getActiveObject();
            if (!obj) return;
            if (obj.type === 'activeSelection') {
                obj.forEachObject(o => setLockState(o, true));
                canvas.discardActiveObject();
            } else {
                setLockState(obj, true);
                canvas.discardActiveObject();
            }
            canvas.renderAll();
            renderLayerList();
            saveHistory();
            hideFloatingToolbar();
        }

        function unlockSelectedAction() {
            // Usually we can't select locked objects via canvas, 
            // so this works if multiple are selected and some are locked (panned/ctrl+a?)
            // Or if we select a group that contains locked objects.
            const obj = canvas.getActiveObject();
            if (!obj) return;
            if (obj.type === 'activeSelection') {
                obj.forEachObject(o => setLockState(o, false));
            } else {
                setLockState(obj, false);
            }
            canvas.renderAll();
            renderLayerList();
            saveHistory();
        }

        function setLockState(obj, isLocked) {
            obj.set({
                lockMovementX: isLocked,
                lockMovementY: isLocked,
                lockScalingX: isLocked,
                lockScalingY: isLocked,
                lockRotation: isLocked,
                selectable: !isLocked,
                hasControls: !isLocked
            });
        }

        // --- COLOR PICKER LOGIC ---
        function initColorPicker() {
            const sbCanvas = document.getElementById('picker-sb-canvas');
            const hueCanvas = document.getElementById('picker-hue-canvas');
            const alphaCanvas = document.getElementById('picker-alpha-canvas');

            const resize = (canvas, w, h) => {
                canvas.width = w;
                canvas.height = h;
            };

            resize(sbCanvas, 216, 150);
            resize(hueCanvas, 216, 12);
            resize(alphaCanvas, 216, 12);

            setupPickerEvents();
            drawHueCanvas();
        }

        function setupPickerEvents() {
            const sbArea = document.getElementById('picker-sb-area');
            const hueArea = document.getElementById('picker-hue-area');
            const alphaArea = document.getElementById('picker-alpha-area');

            const handleSB = (e) => {
                const rect = sbArea.getBoundingClientRect();
                pickerSaturation = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
                pickerBrightness = Math.max(0, Math.min(1, 1 - (e.clientY - rect.top) / rect.height));
                updatePickerUI(true);
            };

            const handleHue = (e) => {
                const rect = hueArea.getBoundingClientRect();
                pickerHue = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width)) * 360;
                updatePickerUI(true);
            };

            const handleAlpha = (e) => {
                const rect = alphaArea.getBoundingClientRect();
                pickerAlpha = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
                updatePickerUI(true);
            };

            const setupDrag = (el, fn) => {
                const onMove = (e) => fn(e);
                const onUp = () => {
                    window.removeEventListener('mousemove', onMove);
                    window.removeEventListener('mouseup', onUp);
                };
                el.addEventListener('mousedown', (e) => {
                    fn(e);
                    window.addEventListener('mousemove', onMove);
                    window.addEventListener('mouseup', onUp);
                });
            };

            setupDrag(sbArea, handleSB);
            setupDrag(hueArea, handleHue);
            setupDrag(alphaArea, handleAlpha);

            document.getElementById('picker-hex').addEventListener('change', (e) => {
                setPickerColor(e.target.value);
            });

            document.getElementById('picker-opacity').addEventListener('change', (e) => {
                pickerAlpha = parseFloat(e.target.value) / 100;
                updatePickerUI(true);
            });

            // CMYK slider and input sync
            const handleCmykChange = () => {
                const c = parseFloat(document.getElementById('picker-cmyk-c').value) || 0;
                const m = parseFloat(document.getElementById('picker-cmyk-m').value) || 0;
                const y = parseFloat(document.getElementById('picker-cmyk-y').value) || 0;
                const k = parseFloat(document.getElementById('picker-cmyk-k').value) || 0;
                pickerCmyk = {
                    c: Math.max(0, Math.min(100, c)),
                    m: Math.max(0, Math.min(100, m)),
                    y: Math.max(0, Math.min(100, y)),
                    k: Math.max(0, Math.min(100, k))
                };
                const rgb = cmykToRgb(pickerCmyk.c, pickerCmyk.m, pickerCmyk.y, pickerCmyk.k);
                const hsv = rgbToHsv(rgb.r, rgb.g, rgb.b);
                pickerHue = hsv.h;
                pickerSaturation = hsv.s;
                pickerBrightness = hsv.v;
                updatePickerUI(false);
                const rgbaStr = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${pickerAlpha})`;
                applyColorToTarget(rgbaStr, pickerCmyk);
            };

            ['c', 'm', 'y', 'k'].forEach((channel) => {
                const slider = document.getElementById(`picker-cmyk-${channel}-slider`);
                const input = document.getElementById(`picker-cmyk-${channel}`);

                // Slider → Input sync
                slider.addEventListener('input', (e) => {
                    input.value = e.target.value;
                    handleCmykChange();
                });

                // Input → Slider sync
                input.addEventListener('input', (e) => {
                    const val = Math.max(0, Math.min(100, parseFloat(e.target.value) || 0));
                    slider.value = val;
                    handleCmykChange();
                });
            });

            window.addEventListener('mousedown', (e) => {
                const picker = document.getElementById('color-picker');
                if (!picker.contains(e.target) && !e.target.classList.contains('color-swatch')) {
                    picker.classList.remove('show');
                }
            });
        }

        // Constrain popup position within viewport boundaries
        function constrainPopupPosition(popup, anchorRect, preferredLeft, preferredTop) {
            // Show popup temporarily to measure its actual size
            const wasVisible = popup.classList.contains('show');
            if (!wasVisible) {
                popup.style.visibility = 'hidden';
                popup.classList.add('show');
            }

            const popupRect = popup.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const padding = 10; // Minimum distance from viewport edge

            let left = preferredLeft;
            let top = preferredTop;

            // Adjust horizontal position
            if (left < padding) {
                left = padding;
            } else if (left + popupRect.width > viewportWidth - padding) {
                // Try positioning to the right of anchor instead
                left = anchorRect.right + padding;
                if (left + popupRect.width > viewportWidth - padding) {
                    // Still doesn't fit, align to right edge
                    left = viewportWidth - popupRect.width - padding;
                }
            }

            // Adjust vertical position
            if (top < padding) {
                top = padding;
            } else if (top + popupRect.height > viewportHeight - padding) {
                // Position above anchor instead
                top = anchorRect.top - popupRect.height - padding;
                if (top < padding) {
                    // Still doesn't fit, align to bottom edge
                    top = viewportHeight - popupRect.height - padding;
                }
            }

            // Hide popup if it was hidden before
            if (!wasVisible) {
                popup.classList.remove('show');
                popup.style.visibility = '';
            }

            return { left, top };
        }

        function openPicker(target, el) {
            pickerTarget = target;
            const picker = document.getElementById('color-picker');
            const rect = el.getBoundingClientRect();

            // Calculate preferred position (left of anchor)
            const preferredLeft = rect.left - 250;
            const preferredTop = rect.top;

            // Constrain to viewport
            const position = constrainPopupPosition(picker, rect, preferredLeft, preferredTop);
            picker.style.left = `${position.left}px`;
            picker.style.top = `${position.top}px`;
            picker.classList.add('show');

            const color = el.style.background || '#ffffff';
            const activeObj = canvas.getActiveObject();
            if (activeObj && (pickerTarget === 'fill' || pickerTarget === 'stroke')) {
                const colorData = activeObj[`${pickerTarget}ColorData`];
                if (colorData && colorData.cmyk) {
                    setPickerFromCmyk(colorData.cmyk);
                } else {
                    setPickerColor(color, { apply: false });
                }
            } else {
                setPickerColor(color, { apply: false });
            }
            renderPalette('doc-colors', getDocumentColors());
        }

        function setPickerColor(color, options = {}) {
            if (color === 'transparent') color = 'rgba(0,0,0,0)';
            const rgba = colorToRgba(color);
            const hsv = rgbToHsv(rgba.r, rgba.g, rgba.b);
            pickerHue = hsv.h;
            pickerSaturation = hsv.s;
            pickerBrightness = hsv.v;
            pickerAlpha = rgba.a;
            pickerCmyk = rgbToCmyk(rgba.r, rgba.g, rgba.b);
            updatePickerUI(false);
            if (options.apply !== false) {
                const rgbaStr = `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${pickerAlpha})`;
                applyColorToTarget(rgbaStr, pickerCmyk);
            }
        }

        function updatePickerUI(apply) {
            drawSbCanvas();
            drawAlphaCanvas();

            const rgb = hsvToRgb(pickerHue, pickerSaturation, pickerBrightness);
            const hex = rgbToHex(rgb.r, rgb.g, rgb.b);

            document.getElementById('picker-sb-cursor').style.left = `${pickerSaturation * 100}%`;
            document.getElementById('picker-sb-cursor').style.top = `${(1 - pickerBrightness) * 100}%`;
            document.getElementById('picker-hue-cursor').style.left = `${(pickerHue / 360) * 100}%`;
            document.getElementById('picker-alpha-cursor').style.left = `${pickerAlpha * 100}%`;

            document.getElementById('picker-hex').value = hex.toUpperCase();
            document.getElementById('picker-opacity').value = Math.round(pickerAlpha * 100);
            pickerCmyk = rgbToCmyk(rgb.r, rgb.g, rgb.b);
            updateCmykInputs(pickerCmyk);

            if (apply) {
                const rgbaStr = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${pickerAlpha})`;
                applyColorToTarget(rgbaStr, pickerCmyk);
            }
        }

        function applyColorToTarget(color, cmyk) {
            if (!pickerTarget) return;
            const activeObj = canvas.getActiveObject();
            const rgba = colorToRgba(color);
            const effectiveCmyk = cmyk || rgbToCmyk(rgba.r, rgba.g, rgba.b);

            if (pickerTarget === 'fill') {
                changeFillColor(color);
                if (activeObj) activeObj.fillColorData = { colorMode: 'cmyk', cmyk: { ...effectiveCmyk }, rgb: { r: rgba.r, g: rgba.g, b: rgba.b } };
            } else if (pickerTarget === 'stroke') {
                changeStrokeColor(color);
                if (activeObj) activeObj.strokeColorData = { colorMode: 'cmyk', cmyk: { ...effectiveCmyk }, rgb: { r: rgba.r, g: rgba.g, b: rgba.b } };
            } else if (pickerTarget === 'shadow') {
                changeShadowColor(color);
            }
            else if (pickerTarget === 'grad-start' || pickerTarget === 'grad-end') {
                document.getElementById(pickerTarget + '-swatch').style.background = color;
                updateGradient();
            }
        }

        function setPickerFromCmyk(cmyk) {
            pickerCmyk = {
                c: Math.max(0, Math.min(100, cmyk.c || 0)),
                m: Math.max(0, Math.min(100, cmyk.m || 0)),
                y: Math.max(0, Math.min(100, cmyk.y || 0)),
                k: Math.max(0, Math.min(100, cmyk.k || 0))
            };
            const rgb = cmykToRgb(pickerCmyk.c, pickerCmyk.m, pickerCmyk.y, pickerCmyk.k);
            const hsv = rgbToHsv(rgb.r, rgb.g, rgb.b);
            pickerHue = hsv.h;
            pickerSaturation = hsv.s;
            pickerBrightness = hsv.v;
            updatePickerUI(false);
        }

        function updateCmykInputs(cmyk) {
            document.getElementById('picker-cmyk-c').value = cmyk.c;
            document.getElementById('picker-cmyk-m').value = cmyk.m;
            document.getElementById('picker-cmyk-y').value = cmyk.y;
            document.getElementById('picker-cmyk-k').value = cmyk.k;
            // Sync sliders
            document.getElementById('picker-cmyk-c-slider').value = cmyk.c;
            document.getElementById('picker-cmyk-m-slider').value = cmyk.m;
            document.getElementById('picker-cmyk-y-slider').value = cmyk.y;
            document.getElementById('picker-cmyk-k-slider').value = cmyk.k;
        }

        function drawSbCanvas() {
            const canvas = document.getElementById('picker-sb-canvas');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;

            ctx.fillStyle = `hsl(${pickerHue}, 100%, 50%)`;
            ctx.fillRect(0, 0, w, h);

            const whiteGrad = ctx.createLinearGradient(0, 0, w, 0);
            whiteGrad.addColorStop(0, 'white');
            whiteGrad.addColorStop(1, 'transparent');
            ctx.fillStyle = whiteGrad;
            ctx.fillRect(0, 0, w, h);

            const blackGrad = ctx.createLinearGradient(0, 0, 0, h);
            blackGrad.addColorStop(0, 'transparent');
            blackGrad.addColorStop(1, 'black');
            ctx.fillStyle = blackGrad;
            ctx.fillRect(0, 0, w, h);
        }

        function drawHueCanvas() {
            const canvas = document.getElementById('picker-hue-canvas');
            const ctx = canvas.getContext('2d');
            const grad = ctx.createLinearGradient(0, 0, canvas.width, 0);
            for (let i = 0; i <= 360; i += 30) {
                grad.addColorStop(i / 360, `hsl(${i}, 100%, 50%)`);
            }
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function drawAlphaCanvas() {
            const canvas = document.getElementById('picker-alpha-canvas');
            const ctx = canvas.getContext('2d');
            const rgb = hsvToRgb(pickerHue, pickerSaturation, pickerBrightness);
            const grad = ctx.createLinearGradient(0, 0, canvas.width, 0);
            grad.addColorStop(0, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0)`);
            grad.addColorStop(1, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 1)`);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // --- COLOR HELPERS ---
        function rgbToCmyk(r, g, b) {
            const rNorm = r / 255;
            const gNorm = g / 255;
            const bNorm = b / 255;
            const k = 1 - Math.max(rNorm, gNorm, bNorm);
            if (k === 1) return { c: 0, m: 0, y: 0, k: 100 };
            const c = (1 - rNorm - k) / (1 - k);
            const m = (1 - gNorm - k) / (1 - k);
            const y = (1 - bNorm - k) / (1 - k);
            return {
                c: Math.round(c * 100),
                m: Math.round(m * 100),
                y: Math.round(y * 100),
                k: Math.round(k * 100)
            };
        }

        function cmykToRgb(c, m, y, k) {
            const cNorm = c / 100;
            const mNorm = m / 100;
            const yNorm = y / 100;
            const kNorm = k / 100;
            return {
                r: Math.round(255 * (1 - cNorm) * (1 - kNorm)),
                g: Math.round(255 * (1 - mNorm) * (1 - kNorm)),
                b: Math.round(255 * (1 - yNorm) * (1 - kNorm))
            };
        }

        function colorToRgba(color) {
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = 1;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color;
            ctx.fillRect(0, 0, 1, 1);
            const d = ctx.getImageData(0, 0, 1, 1).data;
            return { r: d[0], g: d[1], b: d[2], a: d[3] / 255 };
        }

        function rgbToHsv(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, v = max;
            const d = max - min;
            s = max === 0 ? 0 : d / max;
            if (max === min) h = 0;
            else {
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return { h: h * 360, s, v };
        }

        function hsvToRgb(h, s, v) {
            let r, g, b;
            const i = Math.floor(h / 60) % 6;
            const f = h / 60 - i;
            const p = v * (1 - s);
            const q = v * (1 - f * s);
            const t = v * (1 - (1 - f) * s);
            switch (i) {
                case 0: r = v, g = t, b = p; break;
                case 1: r = q, g = v, b = p; break;
                case 2: r = p, g = v, b = t; break;
                case 3: r = p, g = q, b = v; break;
                case 4: r = t, g = p, b = v; break;
                case 5: r = v, g = p, b = q; break;
            }
            return { r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255) };
        }

        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }

        function getDocumentColors() {
            const colors = new Set();
            canvas.getObjects().forEach(o => {
                if (typeof o.fill === 'string' && o.fill !== 'transparent') colors.add(o.fill);
                if (typeof o.stroke === 'string' && o.stroke !== 'transparent') colors.add(o.stroke);
            });
            return Array.from(colors).slice(0, 10);
        }

        function renderPalette(id, colors) {
            const container = document.getElementById(id);
            const title = container.querySelector('.palette-title');
            container.innerHTML = '';
            container.appendChild(title);
            colors.forEach(c => {
                const div = document.createElement('div');
                div.className = 'palette-color';
                div.style.background = c;
                div.onclick = () => setPickerColor(c);
                container.appendChild(div);
            });
        }

        window.addEventListener('load', () => {
            initCanvas();
            initColorPicker();
        });
    </script>
</body>

</html>
